diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/sbin/vyatta-dynamic-dns.pl 1Projects/rfc2136.dynamic.dns/opt/vyatta/sbin/vyatta-dynamic-dns.pl
--- ERXv1.8.0/opt/vyatta/sbin/vyatta-dynamic-dns.pl	2016-03-01 18:15:28.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/sbin/vyatta-dynamic-dns.pl	2016-02-28 14:00:53.000000000 -0800
@@ -36,8 +36,8 @@ my $ddclient_run_dir = '/var/run/ddclien
 my $ddclient_cache_dir = '/var/cache/ddclient';
 my $ddclient_config_dir = '/etc/ddclient';
 
-my @fixed_services = qw(afraid dnspark dslreports dyndns easydns namecheap
-                        sitelutions zoneedit);
+my @fixed_services = qw(afraid cloudflare dnspark dslreports dyndns easydns
+                        namecheap sitelutions zoneedit);
 
 my @web_builtins = qw(dyndns dnspark loopia);
 
@@ -45,15 +45,54 @@ my @web_builtins = qw(dyndns dnspark loo
 # main
 #
 
-my ($update_dynamicdns, $op_mode_update_dynamicdns, $stop_dynamicdns,
-    $check_service, $check_web, $interface);
+my %_services_defaults = (
+    afraid => {
+        protocol => "freedns"
+    },
+    changeip => {
+        protocol => "changeip"
+    },
+    cloudflare => {
+        protocol => "cloudflare"
+    },
+    dnspark => {
+        protocol => "dnspark"
+    },
+    dslreports => {
+        protocol => "dslreports1"
+    },
+    dyndns => {
+        protocol => "dyndns2"
+    },
+    easydns => {
+        protocol => "easydns"
+    },
+    namecheap => {
+        protocol => "namecheap"
+    },
+    noip => {
+        protocol => "noip"
+    },
+    sitelutions => {
+        protocol => "sitelutions"
+    },
+    zoneedit => {
+        protocol => "zoneedit1"
+    }
+);
+
+my ($update_dynamicdns, $op_mode_update_dynamicdns, $stop_dynamicdns, $interface, $get_services, $get_default_services, $get_protocols, $check_nodes, $check_service, $check_web);
 
-GetOptions("update-dynamicdns!"            => \$update_dynamicdns,
-           "stop-dynamicdns!"              => \$stop_dynamicdns,
-           "op-mode-update-dynamicdns!"    => \$op_mode_update_dynamicdns,
-           "check-service=s"               => \$check_service,
-           "check-web=s"                   => \$check_web,
-           "interface=s"                   => \$interface);
+GetOptions(
+    "update-dynamicdns!"            => \$update_dynamicdns,
+    "stop-dynamicdns!"              => \$stop_dynamicdns,
+    "op-mode-update-dynamicdns!"    => \$op_mode_update_dynamicdns,
+    "interface=s"                   => \$interface,
+    "get-services!"                 => \$get_services,
+    "get-default-services!"         => \$get_default_services,
+    "get-protocols!"                => \$get_protocols,
+    "check-nodes!"                  => \$check_nodes
+);
 
 if (defined $update_dynamicdns) {
    my $config;
@@ -79,6 +118,11 @@ if (defined($check_web)) {
     do_check_web();
 }
 
+dynamicdns_get_services() if (defined $get_services);
+dynamicdns_get_default_services() if (defined $get_default_services);
+dynamicdns_get_protocols() if (defined $get_protocols);
+dynamicdns_check_nodes() if (defined $check_nodes);
+
 exit 0;
 
 #
@@ -127,6 +171,76 @@ sub dynamicdns_stop {
     system("rm -f $ddclient_cache_dir/ddclient_$interface.cache >&/dev/null");
 }
 
+sub dynamicdns_check_nodes {
+    my $config = new Vyatta::Config;
+    $config->setLevel("service dns dynamic interface $interface");
+
+    my @services = $config->listNodes("service");
+    foreach my $service (@services) {
+        $config->setLevel("service dns dynamic interface $interface service $service");
+
+        # Check if we have a login, a password and host-name(s)
+        if(!defined($config->returnValue('login')) or $config->returnValue('login') eq '') {
+            print "A login must be set for dynamic dns service $service on interface $interface\n";
+            exit 1;
+        }
+        if(!defined($config->returnValue('password')) or $config->returnValue('password') eq '') {
+            print "A password must be set for dynamic dns service $service on interface $interface\n";
+            exit 1;
+        }
+        if(!defined($config->returnValues('host-name')) or $config->returnValues('host-name') eq 0) {
+            print "An host-name must be set for dynamic dns service $service on interface $interface\n";
+            exit 1;
+        }
+
+        # Check if we have a non-default service
+        if(!defined($_services_defaults{$service})) {
+            if(!defined($config->returnValue('protocol')) or $config->returnValue('protocol') eq '') {
+                print "A protocol must be set for custom dynamic dns service $service on interface $interface\n";
+                exit 1;
+            }
+            if(!defined($config->returnValue('server')) or $config->returnValue('server') eq '') {
+                print "A server must be set for custom dynamic dns service $service on interface $interface\n";
+                exit 1;
+            }
+        }
+    }
+    exit 0;
+}
+
+# Will return a string with default services only (those which don't need an explicit server or protocol value)
+sub dynamicdns_get_default_services {
+    print join(' ', keys(%_services_defaults));
+    print "\n";
+}
+
+# Return a list of supported protocols
+sub dynamicdns_get_protocols {
+    for my $service (keys %_services_defaults) {
+        print " $_services_defaults{$service}{'protocol'}";
+    }
+    print "\n";
+}
+
+# Will return a string with default services and set services, useful for CLI completion
+sub dynamicdns_get_services {
+    my @o_services = keys %_services_defaults;
+    my $output;
+    my $config = new Vyatta::Config;
+    $config->setLevel("service dns dynamic interface $interface");
+
+    my @services = $config->listNodes("service");
+    foreach my $service (@services) {
+        push(@o_services, $service);
+    }
+    my @unique_o_services = do {
+        my %seen;
+        grep {!$seen{$_}++} @o_services;
+    };
+    print join(' ', @unique_o_services);
+    print "\n";
+}
+
 sub dynamicdns_get_constants {
     my $output;
 
@@ -143,58 +257,93 @@ sub dynamicdns_get_constants {
 
 sub dynamicdns_get_values {
 
-    my $output = '';
-    my $config = new Vyatta::Config;
-    $config->setLevel("service dns dynamic interface $interface");
-
-    my $web = $config->returnValue("web");
-    my $wskip = $config->returnValue("web-skip");
-    if (defined($web)) {
-        my $webskip = '';
-        if (defined($wskip)) {
-            $webskip = ", web-skip='$wskip'";
-        }
-        $output .= "use=web, web='$web'$webskip\n\n\n";
-    } else {
-        $output .= "use=if, if=$interface\n\n\n";
-    }
-
-    my @services = $config->listNodes("service");
-    foreach my $service (@services) {
-       $config->setLevel("service dns dynamic interface $interface service $service");
-       switch ($service) {
-           case "dslreports" {$service="dslreports1";}
-           case "dyndns"     {$service="dyndns2";}
-           case "zoneedit"   {$service="zoneedit1";}
-           case "afraid"     {$service="freedns";}
-       }
-       my $login = $config->returnValue("login");
-       my $password = $config->returnValue("password");
-       my @hostnames = $config->returnValues("host-name");
-       my $server = $config->returnValue("server");
-       my $opts = $config->returnValue("options");
-       my $proto = $config->returnValue("protocol");
-       if ($service =~ m/^custom-/) {
-          $service = $proto;
-       }
-       if (!defined($service)) {
-          print "Must define \"protocol\" for custom service type\n";
-          exit 1;
-       }
-       foreach my $hostname (@hostnames) {
-          $output .= "server=$server," if defined $server;
-          $output .= "protocol=$service\n";
-          $output .= "max-interval=28d\n";
-          if (defined($opts)) {
-             $output .= "$opts\n";
-          }
-          $output .= "login=$login\n";
-          $output .= "password='$password'\n";
-          $output .= "$hostname\n\n";
-       }
-    }
-
-    return $output;
+	my $output = '';
+	my $config = new Vyatta::Config;
+	$config->setLevel("service dns dynamic interface $interface");
+
+	my $web = $config->returnValue("web");
+	my $wskip = $config->returnValue("web-skip");
+	if (defined($web)) {
+		my $webskip = '';
+		if (defined($wskip)) {
+			$webskip = ", web-skip='$wskip'";
+		}
+		$output .= "use=web, web='$web'$webskip\n\n\n";
+	} else {
+		$output .= "use=if, if=$interface\n\n\n";
+	}
+
+	my @services = $config->listNodes("service");
+	foreach my $service (@services) {
+		$config->setLevel("service dns dynamic interface $interface service $service");
+		switch ($service) {
+			case "afraid"		{$service="freedns";}
+			case "changeip"		{$service="changeip";}
+			case "cloudflare"	{$service="cloudflare";}
+			case "dnspark"		{$service="dnspark";}
+			case "dslreports"	{$service="dslreports1";}
+			case "dyndns"		{$service="dyndns2";}
+			case "easydns"		{$service="easydns";}
+			case "hammernode"	{$service="hammernode1";}
+			case "namecheap"	{$service="namecheap";}
+			case "noip"			{$service="noip";}
+			case "sitelutions"	{$service="sitelutions";}
+			case "zoneedit"		{$service="zoneedit1";}
+		}
+		my $login = $config->returnValue("login");
+		my $password = $config->returnValue("password");
+		my @hostnames = $config->returnValues("host-name");
+		my $server = $config->returnValue("server");
+		my $opts = $config->returnValue("options");
+		my $proto = $config->returnValue("protocol");
+		if ($service =~ m/^custom-/) {
+			$service = $proto;
+		}
+		if (!defined($service)) {
+		  print "Must define \"protocol\" for custom service type\n";
+		  exit 1;
+		}
+		foreach my $hostname (@hostnames) {
+			my $zone;
+			if ($service eq "cloudflare") {
+				$server = "www.cloudflare.com";
+				$zone = $hostname;
+				$zone =~ s/.*?\.//;
+			}
+			$output .= "server=$server," if defined $server;
+			$output .= "protocol=$service\n";
+			$output .= "max-interval=28d\n";
+			if (defined($opts)) {
+				$output .= "$opts\n";
+			}
+			$output .= "login=$login\n";
+			$output .= "password='$password'\n";
+			$output .= "zone=$zone\n" if defined $zone;
+			$output .= "$hostname\n\n";
+			}
+		}
+
+		$config->setLevel("service dns dynamic interface $interface");
+		my @rfc2136s = $config->listNodes("rfc2136");
+		foreach my $rfc2136 (@rfc2136s) {
+			$config->setLevel("service dns dynamic interface $interface rfc2136 $rfc2136");
+			my $key_file = $config->returnValue("key");
+			my @records = $config->returnValues("record");
+			my $server = $config->returnValue("server");
+			my $ttl = $config->returnValue("ttl");
+			my $zone = $config->returnValue("zone");
+
+			foreach my $record (@records) {
+				$output .= "server=$server\n";
+				$output .= "protocol=nsupdate\n";
+				$output .= "login=/usr/bin/nsupdate\n";
+				$output .= "password=$key_file\n";
+				$output .= "ttl=$ttl\n";
+				$output .= "zone=$zone\n";
+				$output .= "$record\n\n";
+			}
+		}
+		return $output;
 }
 
 sub dynamicdns_write_file {
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.def	2016-03-01 18:15:28.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.def	2015-06-04 20:43:08.000000000 -0700
@@ -1,15 +1,9 @@
 tag:
 help: Interface to send DDNS updates for [REQUIRED]
 type: txt
-
-allowed:/usr/sbin/ubnt-ifctl list-sys-intfs all
-
-syntax:expression: pattern $VAR(@) "^[[:alnum:]][-_.[:alnum:]]*[[:alnum:]]$"
-                   ; "Invalid interface name"
- 
-commit:expression: $VAR(./@/service/@@) != ""; "At least one service must be set to send DDNS updates for $VAR(@)"
-
-commit:expression: exec "/usr/sbin/ubnt-ifctl valid-intf $VAR(@) all warn"
+allowed: /opt/vyatta/sbin/vyatta-interfaces.pl --show=all
+commit:expression: $VAR(./@/service/@@) != "" || $VAR(./@/rfc2136/@@) != ""; "At least one service must be set to send DDNS updates for $VAR(@)"
+commit:expression: exec "/opt/vyatta/sbin/vyatta-interfaces.pl --dev=$VAR(@) --warn"
 
 delete:touch /tmp/ddclient_$VAR(@).$PPID
 
@@ -19,3 +13,4 @@ end: if [ -f /tmp/ddclient_$VAR(@).$PPID
      else
         sudo /opt/vyatta/sbin/vyatta-dynamic-dns.pl --update-dynamicdns --interface $VAR(@)
      fi
+
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,8 @@
+tag:
+help: RFC2136 Update name
+type: txt
+
+commit:expression: $VAR(./@/zone) != ""; "Set zone for service $VAR(./@) to send DDNS updates for interface $VAR(../@)"
+commit:expression: $VAR(./@/key) != ""; "Set key for service $VAR(./@) to send DDNS updates for interface $VAR(../@)"
+commit:expression: $VAR(./@/record) != ""; "Set record for service $VAR(./@) to send DDNS updates for interface $VAR(../@)"
+commit:expression: $VAR(./@/server) != ""; "Set server for service $VAR(./@) to send DDNS updates for interface $VAR(../@)"
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/key/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/key/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/key/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/key/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,4 @@
+type: txt
+help: File containing the secret key shared with remote DNS server [REQUIRED]
+syntax:expression: exec "/opt/vyatta/sbin/check_file_in_config_dir $VAR(@) '/config/auth'"
+val_help: File in /config/auth
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/record/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/record/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/record/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/record/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,3 @@
+multi:
+help: Record to be updated [REQUIRED]
+type: txt
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/server/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/server/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/server/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/server/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,2 @@
+help: Server to be updated [REQUIRED]
+type: txt
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/ttl/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/ttl/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/ttl/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/ttl/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,5 @@
+type: u32
+
+help: Time To Live
+
+default: 600
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/zone/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/zone/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/zone/node.def	1969-12-31 16:00:00.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/rfc2136/node.tag/zone/node.def	2015-06-04 12:49:22.000000000 -0700
@@ -0,0 +1,2 @@
+help: Zone to be updated [REQUIRED]
+type: txt
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/service/node.def 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/service/node.def
--- ERXv1.8.0/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/service/node.def	2016-03-01 18:15:28.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/opt/vyatta/share/vyatta-cfg/templates/service/dns/dynamic/interface/node.tag/service/node.def	2015-06-12 17:07:19.000000000 -0700
@@ -1,11 +1,21 @@
 tag:
 help: Service being used for Dynamic DNS [REQUIRED]
 type: txt
-syntax:expression: exec "/opt/vyatta/sbin/vyatta-dynamic-dns.pl \
-                            --check-service '$VAR(@)'"
+syntax:expression: exec "
+        service_array=(afraid changeip cloudflare concont dnspark dslreports dtnds duckdns dyndns easydns googledomains hammernode namecheap noip nsupdate sitelutions zoneedit)
+        service_array_len=${#service_array[*]}
+        i=0
+        while [ $i -lt $service_array_len ]; do
+             if [ \"${service_array[$i]}\" == \"$VAR(@)\" ] ; then
+                   exit 0
+             fi
+             let i++
+        done
+        echo Invalid service [$VAR(@)]
+        exit 1 "
 
 allowed: local -a array ;
-         array=(afraid dnspark dslreports dyndns easydns namecheap sitelutions zoneedit);
+         array=(afraid changeip cloudflare concont dnspark dslreports dtnds duckdns dyndns easydns googledomains hammernode namecheap noip nsupdate sitelutions zoneedit);
          echo -n ${array[@]}
 
 commit:expression: $VAR(./@/login) != ""; "Set login for service $VAR(./@) to send DDNS updates for interface $VAR(../@)"
diff -rupN -x'ddns*' -x .DS_Store -x .git ERXv1.8.0/usr/sbin/ddclient 1Projects/rfc2136.dynamic.dns/usr/sbin/ddclient
--- ERXv1.8.0/usr/sbin/ddclient	2016-03-01 18:16:10.000000000 -0800
+++ 1Projects/rfc2136.dynamic.dns/usr/sbin/ddclient	2015-06-08 15:03:16.000000000 -0700
@@ -1,7 +1,7 @@
 #!/usr/bin/perl -w
 #!/usr/local/bin/perl -w
 ######################################################################
-# $Id: ddclient 157 2013-12-26 09:02:05Z wimpunk $
+# $Id: ddclient 184 2015-05-28 19:59:34Z wimpunk $
 #
 # DDCLIENT - a Perl client for updating DynDNS information
 #
@@ -13,6 +13,11 @@
 # Support for multiple IP numbers added by
 # Astaro AG, Ingo Schwarze <ischwarze-OOs/4mkCeqbQT0dZR+AlfA@public.gmane.org> September 16, 2008
 #
+# Support for multiple domain support for Namecheap by Robert Ian Hawdon 2010-09-03: https://robertianhawdon.me.uk/
+#
+# Initial Cloudflare support by Ian Pye, updated by Robert Ian Hawdon 2012-07-16
+# Further updates by Peter Roberts to support the new API 2013-09-26, 2014-06-22: http://blog.peter-r.co.uk/
+#
 ######################################################################
 require 5.004;
 use strict;
@@ -20,16 +25,16 @@ use Getopt::Long;
 use Sys::Hostname;
 use IO::Socket;
 
-my ($VERSION) = q$Revision: 157 $ =~ /(\d+)/;
+# my ($VERSION) = q$Revision: 184 $ =~ /(\d+)/;
 
-my $version  = "3.8.2";
-my $programd  = $0;
+my $version  = "3.8.3";
+my $programd  = $0; 
 $programd =~ s%^.*/%%;
 my $program   = $programd;
 $program  =~ s/d$//;
 my $now       = time;
 my $hostname  = hostname();
-my $etc       = ($program =~ /test/i) ? './'   : '/etc/';
+my $etc       = ($program =~ /test/i) ? './'   : '/etc/ddclient/';
 my $cachedir  = ($program =~ /test/i) ? './'   : '/var/cache/ddclient/';
 my $savedir   = ($program =~ /test/i) ? 'URL/' : '/tmp/';
 my $msgs      = '';
@@ -41,266 +46,261 @@ local $lineno = '';
 
 $ENV{'PATH'} = (exists($ENV{PATH}) ? "$ENV{PATH}:" : "") . "/sbin:/usr/sbin:/bin:/usr/bin:/etc:/usr/lib:";
 
-sub T_ANY	{'any'};
+sub T_ANY		{'any'};
 sub T_STRING	{'string'};
-sub T_EMAIL	{'e-mail address'};
+sub T_EMAIL		{'e-mail address'};
 sub T_NUMBER	{'number'};
-sub T_DELAY	{'time delay (ie. 1d, 1hour, 1m)'};
-sub T_LOGIN	{'login'};
+sub T_DELAY		{'time delay (ie. 1d, 1hour, 1m)'};
+sub T_LOGIN		{'login'};
 sub T_PASSWD	{'password'};
-sub T_BOOL	{'boolean value'};
-sub T_FQDN	{'fully qualified host name'};
-sub T_OFQDN	{'optional fully qualified host name'};
-sub T_FILE	{'file name'};
-sub T_FQDNP	{'fully qualified host name and optional port number'};
-sub T_PROTO	{'protocol'}
-sub T_USE	{'ip strategy'}
+sub T_BOOL		{'boolean value'};
+sub T_FQDN		{'fully qualified host name'};
+sub T_OFQDN		{'optional fully qualified host name'};
+sub T_FILE		{'file name'};
+sub T_FQDNP		{'fully qualified host name and optional port number'};
+sub T_PROTO		{'protocol'}
+sub T_USE		{'ip strategy'}
 sub T_IF        {'interface'}
 sub T_PROG      {'program name'}
 sub T_IP        {'ip'}
-sub T_POSTS	{'postscript'};
+sub T_POSTS		{'postscript'};
 
 ## strategies for obtaining an ip address.
 my %builtinweb = (
-   'dyndns'       => { 'url' => 'http://checkip.dyndns.org/', 'skip' =>
-   'Current IP Address:', },
-   'dnspark'      => { 'url' => 'http://ipdetect.dnspark.com/', 'skip' => 'Current Address:', },
-   'loopia'       => { 'url' => 'http://dns.loopia.se/checkip/checkip.php', 'skip' => 'Current Address:', },
+	'dyndns'	=> { 'url' => 'http://checkip.dyndns.org/', 'skip' => 'Current IP Address:', },
+	'dnspark'	=> { 'url' => 'http://ipdetect.dnspark.com/', 'skip' => 'Current Address:', },
+	'loopia'	=> { 'url' => 'http://dns.loopia.se/checkip/checkip.php', 'skip' => 'Current IP Address:', },
 );
 my %builtinfw = (
-    'watchguard-soho'        => {
-				  'name' => 'Watchguard SOHO FW',
-				  'url'  => '/pubnet.htm',
-				  'skip' => 'NAME=IPAddress VALUE=',
-			        },
-    'netopia-r910'           => {
-				  'name' => 'Netopia R910 FW',
-				  'url'  => '/WanEvtLog',
-				  'skip' => 'local:',
-			        },
-    'smc-barricade'          => {
-				  'name' => 'SMC Barricade FW',
-				  'url'  => '/status.htm',
-				  'skip' => 'IP Address',
-			        },
-    'smc-barricade-alt'      => {
-				  'name' => 'SMC Barricade FW (alternate config)',
-				  'url'  => '/status.HTM',
-				  'skip' => 'WAN IP',
-			        },
-    'smc-barricade-alt'      => {
-				  'name' => 'SMC Barricade FW (alternate config)',
-				  'url'  => '/status.HTM',
-				  'skip' => 'WAN IP',
-			        },
-    'smc-barricade-7401bra'  => {
-				  'name' => 'SMC Barricade 7401BRA FW',
-				  'url'  => '/admin/wan1.htm',
-				  'skip' => 'IP Address',
-			        },
-    'netgear-rt3xx'          => {
-				  'name' => 'Netgear FW',
-				  'url'  => '/mtenSysStatus.html',
-				  'skip' => 'IP Address',
-			        },
-    'elsa-lancom-dsl10'      => {
-				  'name' => 'ELSA LanCom DSL/10 DSL FW',
-				  'url'  => '/config/1/6/8/3/',
-				  'skip' => 'IP.Address',
-			        },
-    'elsa-lancom-dsl10-ch01' => {
-	 			  'name' => 'ELSA LanCom DSL/10 DSL FW (isdn ch01)',
-				  'url'  => '/config/1/6/8/3/',
-				  'skip' => 'IP.Address.*?CH01',
-			        },
-    'elsa-lancom-dsl10-ch02' => {
-	                          'name' => 'ELSA LanCom DSL/10 DSL FW (isdn ch01)',
-				  'url'  => '/config/1/6/8/3/',
-				  'skip' => 'IP.Address.*?CH02',
-			        },
-    'linksys'                => {
-	                          'name' => 'Linksys FW',
-				  'url'  => '/Status.htm',
-				  'skip' => 'WAN.*?Address',
-			        },
-    'linksys-ver2'                => {
-	                          'name' => 'Linksys FW version 2',
-				  'url'  => '/RouterStatus.htm',
-				  'skip' => 'WAN.*?Address',
-			        },
-    'linksys-ver3'                => {
-	                          'name' => 'Linksys FW version 3',
-                                 'url'  => '/Status_Router.htm',
-				  'skip' => 'WAN.*?Address',
-			        },
-     'linksys-wrt854g'        => {
-                                 'name' => 'Linksys WRT854G FW',
-                                 'url'  => '/Status_Router.asp',
-                                 'skip' => 'IP Address:',
-                               },
-    'maxgate-ugate3x00'      => {
-	                          'name' => 'MaxGate UGATE-3x00 FW',
-	                          'url'  => '/Status.htm',
-				  'skip' => 'WAN.*?IP Address',
-                                },
-     'netcomm-nb3' => {
-				'name' => 'NetComm NB3',
-				'url' => '/MainPage?id=6',
-				'skip' => 'ppp-0',
-				},
-    '3com-3c886a'            => {
-    				  'name' => '3com 3c886a 56k Lan Modem',
-                                  'url'  => '/stat3.htm',
-                                  'skip' => 'IP address in use',
-                                },
-    'sohoware-nbg800'        => {
-    				  'name' => 'SOHOWare BroadGuard NBG800',
-                                  'url'  => '/status.htm',
-                                  'skip' => 'Internet IP',
-                                },
-    'xsense-aero'	     => {
-	                          'name' => 'Xsense Aero',
-	                          'url'  => '/A_SysInfo.htm',
-				  'skip' => 'WAN.*?IP Address',
-                                },
-    'alcatel-stp'            => {
-				  'name' => 'Alcatel Speed Touch Pro',
-				  'url'  => '/cgi/router/',
-                                  'skip' => 'Brt',
-				},
-    'alcatel-510'            => {
-                                  'name' => 'Alcatel Speed Touch 510',
-                                  'url'  => '/cgi/ip/',
-                                  'skip' => 'ppp',
-                                },
-    'allnet-1298'            => {
-                                  'name' => 'Allnet 1298',
-                                  'url'  => '/cgi/router/',
-                                  'skip' => 'WAN',
-                                },
-    '3com-oc-remote812'      => {
-    				  'name' => '3com OfficeConnect Remote 812',
-                                  'url'  => '/callEvent',
-                                  'skip' => '.*LOCAL',
-                                },
-    'e-tech'		     => {
-				  'name' => 'E-tech Router',
-				  'url'  => '/Status.htm',
-				  'skip' => 'Public IP Address',
-                              },
-    'cayman-3220h'	     => {
-				  'name' => 'Cayman 3220-H DSL',
-				  'url'  => '/shell/show+ip+interfaces',
-				  'skip' => '.*inet',
-                              },
-    'vigor-2200usb'           => {
-				  'name' => 'Vigor 2200 USB',
-				  'url'  => '/doc/online.sht',
-				  'skip' => 'PPPoA',
-			      },
-    'dlink-614'            => {
-				  'name' => 'D-Link DI-614+',
-				  'url'  => '/st_devic.html',
-				  'skip' => 'WAN',
-			      },
-    'dlink-604'            => {
-				  'name' => 'D-Link DI-604',
-				  'url'  => '/st_devic.html',
-				  'skip' => 'WAN.*?IP.*Address',
-			      },
-    'olitec-SX200'            => {
-				  'name' => 'olitec-SX200',
-				  'url'  => '/doc/wan.htm',
-				  'skip' => 'st_wan_ip[0] = "',
-			      },
-    'westell-6100'            => {
-				  'name' => 'Westell C90-610015-06 DSL Router',
-				  'url'  => '/advstat.htm',
-				  'skip' => 'IP.+?Address',
-			      },
-     '2wire'                  => {
-                                 'name' => '2Wire 1701HG Gateway',
-                                 'url'  => '/xslt?PAGE=B01',
-                                 'skip' => 'Internet Address:',
-                               },
-    'linksys-rv042-wan1' => {
-        'name' => 'Linksys RV042 Dual Homed Router WAN Port 2',
-        'url' => '/home.htm',
-        'skip' => 'WAN1 IP',
-    },
-    'linksys-rv042-wan2' => {
-        'name' => 'Linksys RV042 Dual Homed Router WAN Port 2',
-        'url' => '/home.htm',
-        'skip' => 'WAN2 IP',
-    },
-    'netgear-rp614' => {
-        'name' => 'Netgear RP614 FW',
-        'url' => '/sysstatus.html',
-        'skip' => 'IP Address',
-    },
-    'watchguard-edge-x' => {
-        'name' => 'Watchguard Edge X FW',
-        'url' => '/netstat.htm',
-        'skip' => 'inet addr:',
-    },
-    'dlink-524' => {
-        'name' => 'D-Link DI-524',
-        'url' => '/st_device.html',
-        'skip' => 'WAN.*?Addres',
-    },
-    'rtp300' => {
-        'name' => 'Linksys RTP300',
-        'url' => '/cgi-bin/webcm?getpage=%2Fusr%2Fwww_safe%2Fhtml%2Fstatus%2FRouter.html',
-        'skip' => 'Internet.*?IP Address',
-    },
-    'netgear-wpn824' => {
-        'name' => 'Netgear WPN824 FW',
-        'url' => '/RST_status.htm',
-        'skip' => 'IP Address',
-    },
-    'linksys-wcg200' => {
-        'name' => 'Linksys WCG200 FW',
-        'url' => '/RgStatus.asp',
-        'skip' => 'WAN.IP.*?Address',
-    },
-    'netgear-dg834g' => {
-        'name' => 'netgear-dg834g',
-        'url' => '/setup.cgi?next_file=s_status.htm&todo=cfg_init',
-        'skip' => '',
-    },
-    'netgear-wgt624' => {
-        'name' => 'Netgear WGT624',
-        'url' => '/RST_st_dhcp.htm',
-        'skip' => 'IP Address</B></td><TD NOWRAP width="50%">',
-    },
-    'sveasoft' => {
-        'name' => 'Sveasoft WRT54G/WRT54GS',
-        'url' => '/Status_Router.asp',
-        'skip' => 'var wan_ip',
-    },
-    'smc-barricade-7004vbr' => {
-        'name' => 'SMC Barricade FW (7004VBR model config)',
-        'url' => '/status_main.stm',
-        'skip' => 'var wan_ip=',
-    },
-    'sitecom-dc202' => {
-        'name' => 'Sitecom DC-202 FW',
-        'url' => '/status.htm',
-        'skip' => 'Internet IP Address',
-    },
+	'watchguard-soho' => {
+		'name' => 'Watchguard SOHO FW',
+		'url'  => '/pubnet.htm',
+		'skip' => 'NAME=IPAddress VALUE=',
+},
+	'netopia-r910' => {
+		'name' => 'Netopia R910 FW',
+		'url'  => '/WanEvtLog',
+		'skip' => 'local:',                
+},
+    'smc-barricade' => {
+		'name' => 'SMC Barricade FW',
+		'url'  => '/status.htm',
+		'skip' => 'IP Address',
+},
+    'smc-barricade-alt' => {
+		'name' => 'SMC Barricade FW (alternate config)',
+		'url'  => '/status.HTM',
+		'skip' => 'WAN IP',
+},
+	'smc-barricade-7401bra' => {
+		'name' => 'SMC Barricade 7401BRA FW',
+		'url'  => '/admin/wan1.htm',
+		'skip' => 'IP Address',
+},
+	'netgear-rt3xx' => {
+		'name' => 'Netgear FW',
+		'url'  => '/mtenSysStatus.html',
+		'skip' => 'IP Address',
+},
+	'elsa-lancom-dsl10' => {
+		'name' => 'ELSA LanCom DSL/10 DSL FW',
+		'url'  => '/config/1/6/8/3/',
+		'skip' => 'IP.Address',
+},
+	'elsa-lancom-dsl10-ch01' => { 
+		'name' => 'ELSA LanCom DSL/10 DSL FW (isdn ch01)',
+		'url'  => '/config/1/6/8/3/',
+		'skip' => 'IP.Address.*?CH01',     
+},
+	'elsa-lancom-dsl10-ch02' => { 
+		'name' => 'ELSA LanCom DSL/10 DSL FW (isdn ch01)',
+		'url'  => '/config/1/6/8/3/',
+		'skip' => 'IP.Address.*?CH02',
+},
+	'linksys'=> {
+		'name' => 'Linksys FW',
+		'url'  => '/Status.htm',
+		'skip' => 'WAN.*?Address',
+},
+	'linksys-ver2' => {
+		'name' => 'Linksys FW version 2',
+		'url'  => '/RouterStatus.htm',
+		'skip' => 'WAN.*?Address',      
+},
+	'linksys-ver3' => {
+		'name' => 'Linksys FW version 3',
+		'url'  => '/Status_Router.htm',
+		'skip' => 'WAN.*?Address',      
+},
+	'linksys-wrt854g' => {
+		'name' => 'Linksys WRT854G FW',
+		'url'  => '/Status_Router.asp',
+		'skip' => 'IP Address:',
+},
+	'maxgate-ugate3x00' => {
+		'name' => 'MaxGate UGATE-3x00 FW',
+		'url'  => '/Status.htm',
+		'skip' => 'WAN.*?IP Address',
+},
+	'netcomm-nb3' => { 
+		'name' => 'NetComm NB3', 
+		'url' => '/MainPage?id=6', 
+		'skip' => 'ppp-0', 
+}, 
+	'3com-3c886a' => {
+		'name' => '3com 3c886a 56k Lan Modem',
+		'url'  => '/stat3.htm',
+		'skip' => 'IP address in use',     
+},
+	'sohoware-nbg800' => {
+		'name' => 'SOHOWare BroadGuard NBG800',
+		'url'  => '/status.htm',
+		'skip' => 'Internet IP',
+},
+	'xsense-aero' => {
+		'name' => 'Xsense Aero',
+		'url'  => '/A_SysInfo.htm',
+		'skip' => 'WAN.*?IP Address',
+},
+	'alcatel-stp' => {
+		'name' => 'Alcatel Speed Touch Pro',
+		'url'  => '/cgi/router/',
+		'skip' => 'Brt',
+},
+	'alcatel-510' => {
+		'name' => 'Alcatel Speed Touch 510',
+		'url'  => '/cgi/ip/',
+		'skip' => 'ppp',
+},
+	'allnet-1298' => {
+		'name' => 'Allnet 1298',
+		'url'  => '/cgi/router/',
+		'skip' => 'WAN',
+},
+	'3com-oc-remote812' => {
+		'name' => '3com OfficeConnect Remote 812',
+		'url'  => '/callEvent',
+		'skip' => '.*LOCAL',
+},
+	'e-tech' => {
+		'name' => 'E-tech Router',
+		'url'  => '/Status.htm',
+		'skip' => 'Public IP Address',
+},
+	'cayman-3220h' => {
+		  'name' => 'Cayman 3220-H DSL',
+		  'url'  => '/shell/show+ip+interfaces',
+		  'skip' => '.*inet',
+},
+	'vigor-2200usb' => {
+		'name' => 'Vigor 2200 USB',
+		'url'  => '/doc/online.sht',
+		'skip' => 'PPPoA',
+},
+	'dlink-614' => {
+		'name' => 'D-Link DI-614+',
+		'url'  => '/st_devic.html',
+		'skip' => 'WAN',
+},
+	'dlink-604' => {
+		'name' => 'D-Link DI-604',
+		'url'  => '/st_devic.html',
+		'skip' => 'WAN.*?IP.*Address',
+},
+	'olitec-SX200' => {
+		'name' => 'olitec-SX200',
+		'url'  => '/doc/wan.htm',
+		'skip' => 'st_wan_ip[0] = "',
+},
+	'westell-6100' => {
+		'name' => 'Westell C90-610015-06 DSL Router',
+		'url'  => '/advstat.htm',
+		'skip' => 'IP.+?Address',
+},
+	'2wire' => {
+		'name' => '2Wire 1701HG Gateway',
+		'url'  => '/xslt?PAGE=B01',
+		'skip' => 'Internet Address:',
+},
+	'linksys-rv042-wan1' => {
+		'name' => 'Linksys RV042 Dual Homed Router WAN Port 2',
+		'url' => '/home.htm',
+		'skip' => 'WAN1 IP',
+},
+	'linksys-rv042-wan2' => {
+		'name' => 'Linksys RV042 Dual Homed Router WAN Port 2',
+		'url' => '/home.htm',
+		'skip' => 'WAN2 IP',
+},
+	'netgear-rp614' => {
+		'name' => 'Netgear RP614 FW',
+		'url' => '/sysstatus.html',
+		'skip' => 'IP Address',
+},
+	'watchguard-edge-x' => {
+		'name' => 'Watchguard Edge X FW',
+		'url' => '/netstat.htm',
+		'skip' => 'inet addr:',
+},
+	'dlink-524' => {
+		'name' => 'D-Link DI-524',
+		'url' => '/st_device.html',
+		'skip' => 'WAN.*?Addres',
+},
+	'rtp300' => {
+		'name' => 'Linksys RTP300',
+		'url' => '/cgi-bin/webcm?getpage=%2Fusr%2Fwww_safe%2Fhtml%2Fstatus%2FRouter.html',
+		'skip' => 'Internet.*?IP Address',
+},
+	'netgear-wpn824' => {
+		'name' => 'Netgear WPN824 FW',
+		'url' => '/RST_status.htm',
+		'skip' => 'IP Address',
+},
+	'linksys-wcg200' => {
+		'name' => 'Linksys WCG200 FW',
+		'url' => '/RgStatus.asp',
+		'skip' => 'WAN.IP.*?Address',
+},
+	'netgear-dg834g' => {
+		'name' => 'netgear-dg834g',
+		'url' => '/setup.cgi?next_file=s_status.htm&todo=cfg_init',
+		'skip' => '',
+},
+	'netgear-wgt624' => {
+		'name' => 'Netgear WGT624',
+		'url' => '/RST_st_dhcp.htm',
+		'skip' => 'IP Address</B></td><TD NOWRAP width="50%">',
+},
+	'sveasoft' => {
+		'name' => 'Sveasoft WRT54G/WRT54GS',
+		'url' => '/Status_Router.asp',
+		'skip' => 'var wan_ip',
+},
+	'smc-barricade-7004vbr' => {
+		'name' => 'SMC Barricade FW (7004VBR model config)',
+		'url' => '/status_main.stm',
+		'skip' => 'var wan_ip=',
+},
+	'sitecom-dc202' => {
+		'name' => 'Sitecom DC-202 FW',
+		'url' => '/status.htm',
+		'skip' => 'Internet IP Address',
+},
 );
+
 my %ip_strategies = (
-     'ip'                     => ": obtain IP from -ip {address}",
-     'web'                    => ": obtain IP from an IP discovery page on the web",
-     'fw'                     => ": obtain IP from the firewall specified by -fw {type|address}",
-     'if'                     => ": obtain IP from the -if {interface}",
-     'cmd'                    => ": obtain IP from the -cmd {external-command}",
-     'cisco'                  => ": obtain IP from Cisco FW at the -fw {address}",
-     'cisco-asa'              => ": obtain IP from Cisco ASA at the -fw {address}",
-     map { $_ => sprintf ": obtain IP from %s at the -fw {address}", $builtinfw{$_}->{'name'} } keys %builtinfw,
+	'ip'				=> ": obtain IP from -ip {address}",
+	'web'				=> ": obtain IP from an IP discovery page on the web",
+	'fw'				=> ": obtain IP from the firewall specified by -fw {type|address}",
+	'if'				=> ": obtain IP from the -if {interface}",
+	'cmd'				=> ": obtain IP from the -cmd {external-command}",
+	'cisco'				=> ": obtain IP from Cisco FW at the -fw {address}",
+	'cisco-asa'			=> ": obtain IP from Cisco ASA at the -fw {address}",
+	map { $_ => sprintf ": obtain IP from %s at the -fw {address}", $builtinfw{$_}->{'name'} } keys %builtinfw,
 );
 sub ip_strategies_usage {
-    return map { sprintf("    -use=%-22s %s.", $_, $ip_strategies{$_}) } sort keys %ip_strategies;
+	return map { sprintf("    -use=%-22s %s.", $_, $ip_strategies{$_}) } sort keys %ip_strategies;
 }
 
 my %web_strategies = (
@@ -350,8 +350,8 @@ my %variables = (
 	'syslog'              => setv(T_BOOL,  0, 0, 1, 0,                    undef),
 	'facility'            => setv(T_STRING,0, 0, 1, 'daemon',             undef),
 	'priority'            => setv(T_STRING,0, 0, 1, 'notice',             undef),
-        'mail'                => setv(T_EMAIL, 0, 0, 1, '',                   undef),
-        'mail-failure'        => setv(T_EMAIL, 0, 0, 1, '',                   undef),
+	'mail'                => setv(T_EMAIL, 0, 0, 1, '',                   undef),
+	'mail-failure'        => setv(T_EMAIL, 0, 0, 1, '',                   undef),
 
 	'exec'                => setv(T_BOOL,  0, 0, 1, 1,                    undef),
 	'debug'               => setv(T_BOOL,  0, 0, 1, 0,                    undef),
@@ -362,8 +362,8 @@ my %variables = (
 	'geturl'              => setv(T_STRING,0, 0, 0, '',                   undef),
 
 	'postscript'          => setv(T_POSTS, 0, 0, 1, '',                   undef),
-    },
-    'service-common-defaults'       => {
+	},
+	'service-common-defaults'       => {
 	'server'	      => setv(T_FQDNP,  1, 0, 1, 'members.dyndns.org', undef),
 	'login'               => setv(T_LOGIN,  1, 0, 1, '',                  undef),
 	'password'            => setv(T_PASSWD, 1, 0, 1, '',                  undef),
@@ -387,7 +387,7 @@ my %variables = (
 	'atime'               => setv(T_NUMBER, 0, 1, 0, 0,                   undef),
 	'status'              => setv(T_ANY,    0, 1, 0, '',                  undef),
 	'min-interval'        => setv(T_DELAY,  0, 0, 1, interval('30s'),     0),
-	'max-interval'        => setv(T_DELAY,  0, 0, 1, interval('30d'),     0),
+	'max-interval'        => setv(T_DELAY,  0, 0, 1, interval('25d'),     0),
 	'min-error-interval'  => setv(T_DELAY,  0, 0, 1, interval('5m'),      0),
 
 	'warned-min-interval'       => setv(T_ANY,    0, 1, 0, 0,             undef),
@@ -412,7 +412,7 @@ my %variables = (
 	'static'              => setv(T_BOOL,   0, 1, 1, 0,                   undef),
     },
     'noip-service-common-defaults'       => {
-	'server'	      => setv(T_FQDNP,  1, 0, 1, 'dynupdate.no-ip.com', undef),
+	'server'              => setv(T_FQDNP,  1, 0, 1, 'dynupdate.no-ip.com', undef),
 	'login'               => setv(T_LOGIN,  1, 0, 1, '',                  undef),
 	'password'            => setv(T_PASSWD, 1, 0, 1, '',                  undef),
 	'host'                => setv(T_STRING, 1, 1, 1, '',                  undef),
@@ -434,6 +434,25 @@ my %variables = (
 	'login'               => setv(T_LOGIN,  0, 0, 0, 'unused',            undef),
 	'client'              => setv(T_STRING, 0, 1, 1, $program,            undef),
     },
+    'nsupdate-common-defaults' => {
+	'ttl'                 => setv(T_NUMBER, 0, 1, 0, 600,                 undef),
+	'zone'                => setv(T_STRING, 1, 1, 1, '',                  undef),
+    },
+	'cloudflare-common-defaults'       => {
+		'server'	      => setv(T_FQDNP,  1, 0, 1, 'www.cloudflare.com', undef),
+		'zone'                => setv(T_FQDN,   1, 0, 1, '',                  undef),
+		'static'              => setv(T_BOOL,   0, 1, 1, 0,                   undef),
+		'wildcard'            => setv(T_BOOL,   0, 1, 1, 0,                   undef),
+		'mx'	              => setv(T_OFQDN,  0, 1, 1, '',                  undef),
+		'backupmx'            => setv(T_BOOL,   0, 1, 1, 0,                   undef),
+	},
+	'googledomains-common-defaults'       => {
+		'server'	      => setv(T_FQDNP,  1, 0, 1, 'domains.google.com', undef),
+	},
+	'duckdns-common-defaults'       => {
+			'server'              => setv(T_FQDNP,  1, 0, 1, 'www.duckdns.org', undef),
+			'login'               => setv(T_LOGIN,  0, 0, 0, 'unused',            undef),
+	},
 );
 my %services = (
     'dyndns1' => {
@@ -462,21 +481,21 @@ my %services = (
 	'update'     => \&nic_noip_update,
 	'examples'   => \&nic_noip_examples,
 	'variables'  => merge(
-			  { 'custom'  => setv(T_BOOL,   0, 1, 1, 0, undef),	},
-			  $variables{'noip-common-defaults'},
-			  $variables{'noip-service-common-defaults'},
-		        ),
+			{ 'custom'  => setv(T_BOOL,   0, 1, 1, 0, undef),	},
+			$variables{'noip-common-defaults'},
+			$variables{'noip-service-common-defaults'},
+			),
     },
     'concont' => {
         'updateable' => undef,
         'update'     => \&nic_concont_update,
         'examples'   => \&nic_concont_examples,
         'variables'  => merge(
-                          $variables{'service-common-defaults'},
-                          { 'mx'       => setv(T_OFQDN,  0, 1, 1, '', undef), },
-                          { 'wildcard' => setv(T_BOOL,   0, 1, 1,  0, undef), },
-                        ),
-    },
+			$variables{'service-common-defaults'},
+			{ 'mx'       => setv(T_OFQDN,  0, 1, 1, '', undef), },
+			{ 'wildcard' => setv(T_BOOL,   0, 1, 1,  0, undef), },
+			),
+    },  
     'dslreports1' => {
 	'updateable' => undef,
 	'update'     => \&nic_dslreports1_update,
@@ -578,6 +597,46 @@ my %services = (
 			  $variables{'service-common-defaults'},
 		        ),
     },
+    'nsupdate' => {
+	'updateable' => undef,
+	'update'     => \&nic_nsupdate_update,
+	'examples'   => \&nic_nsupdate_examples,
+	'variables'  => merge(
+			  { 'login'        => setv(T_LOGIN, 1, 0, 1, '/usr/bin/nsupdate', undef), },
+			  $variables{'nsupdate-common-defaults'},
+			  $variables{'service-common-defaults'},
+	),
+    },
+    'cloudflare' => {
+        'updateable' => undef,
+        'update'     => \&nic_cloudflare_update,
+        'examples'   => \&nic_cloudflare_examples,
+        'variables'  => merge(
+            { 'server'       => setv(T_FQDNP,  1, 0, 1, 'www.cloudflare.com', undef)          },
+            { 'min-interval' => setv(T_DELAY,  0, 0, 1, interval('5m'), 0),},
+            $variables{'cloudflare-common-defaults'},
+            $variables{'service-common-defaults'},
+        ),
+    },
+    'googledomains' => {
+        'updateable' => undef,
+        'update'     => \&nic_googledomains_update,
+        'examples'   => \&nic_googledomains_examples,
+        'variables'  => merge(
+            { 'min-interval' => setv(T_DELAY,  0, 0, 1, interval('5m'), 0),},
+            $variables{'googledomains-common-defaults'},
+            $variables{'service-common-defaults'},
+            ),
+    },
+    'duckdns' => {
+        'updateable' => undef,
+        'update'     => \&nic_duckdns_update,
+        'examples'   => \&nic_duckdns_examples,
+        'variables'  => merge(
+                          $variables{'duckdns-common-defaults'},
+                          $variables{'service-common-defaults'},
+                        ),
+    },
 );
 $variables{'merged'} = merge($variables{'global-defaults'},
 			     $variables{'service-common-defaults'},
@@ -589,19 +648,19 @@ my @opt = (
     "usage: ${program} [options]",
     "options are:",
     [ "daemon",      "=s", "-daemon delay         : run as a daemon, specify delay as an interval." ],
-+     [ "foreground",  "!",  "-foreground           : do not fork" ],
+    [ "foreground",  "!",  "-foreground           : do not fork" ],
     [ "proxy",       "=s", "-proxy host           : use 'host' as the HTTP proxy" ],
     [ "server",      "=s", "-server host          : update DNS information on 'host'" ],
     [ "protocol",    "=s", "-protocol type        : update protocol used" ],
     [ "file",        "=s", "-file path            : load configuration information from 'path'" ],
     [ "cache",       "=s", "-cache path           : record address used in 'path'" ],
     [ "pid",         "=s", "-pid path             : record process id in 'path'" ],
-    "",
+    "",			     
     [ "use",         "=s", "-use which            : how the should IP address be obtained." ],
                                                   &ip_strategies_usage(),
-    "",
+    "",			     
     [ "ip",          "=s", "-ip address           : set the IP address to 'address'" ],
-    "",
+    "",			     
     [ "if",          "=s", "-if interface         : obtain IP address from 'interface'" ],
     [ "if-skip",     "=s", "-if-skip pattern      : skip any IP addresses before 'pattern' in the output of ifconfig {if}" ],
     "",
@@ -612,16 +671,16 @@ my @opt = (
     [ "fw-skip",     "=s", "-fw-skip pattern      : skip any IP addresses before 'pattern' on the firewall address|url" ],
     [ "fw-login",    "=s", "-fw-login login       :   use 'login' when getting IP from fw" ],
     [ "fw-password", "=s", "-fw-password secret   :   use password 'secret' when getting IP from fw" ],
-    "",
+    "",			     
     [ "cmd",         "=s", "-cmd program          : obtain IP address from by calling {program}" ],
     [ "cmd-skip",    "=s", "-cmd-skip pattern     : skip any IP addresses before 'pattern' in the output of {cmd}" ],
-    "",
+    "",			     
     [ "login",       "=s", "-login user           : login as 'user'" ],
     [ "password",    "=s", "-password secret      : use password 'secret'" ],
     [ "host",        "=s", "-host host            : update DNS information for 'host'" ],
-    "",
+    "",			     
     [ "options",     "=s",  "-options opt,opt     : optional per-service arguments (see below)" ],
-    "",
+    "",			     
     [ "ssl",         "!",  "-{no}ssl              : do updates over encrypted SSL connection" ],
     [ "retry",       "!",  "-{no}retry            : retry failed updates." ],
     [ "force",       "!",  "-{no}force            : force an update even if the update may be unnecessary" ],
@@ -697,7 +756,7 @@ if (opt('foreground') || opt('force')) {
 }
 
 # write out the pid file if we're daemon'ized
-if(opt('daemon')) {
+if(opt('daemon')) { 
     write_pid();
     $opt{'syslog'} = 1;
 }
@@ -722,7 +781,7 @@ do {
 #   usage("invalid argument '-use %s'; possible values are:\n\t%s", $opt{'use'}, join("\n\t,",sort keys %ip_strategies))
     usage("invalid argument '-use %s'; possible values are:\n%s", $opt{'use'}, join("\n",ip_strategies_usage()))
       unless exists $ip_strategies{lc opt('use')};
-
+    
     $daemon = $opt{'daemon'};
     $daemon = 0 if opt('force');
 
@@ -772,10 +831,10 @@ sub runpostscript {
 		if ( -x $globals{postscript}) {
 			system ("$globals{postscript} $ip &");
 		} else {
-			warning ("Can not execute post script: %s", $globals{postscript});
+			warning ("Can not execute post script: %s", $globals{postscript}); 
 		}
 	}
-}
+} 
 
 ######################################################################
 ## update_nics
@@ -828,7 +887,7 @@ sub update_nics {
 	}
 	foreach my $h (sort keys %config) {
 		if (!exists $examined{$h}) {
-			failed("%s was not updated because protocol %s is not supported.",
+			failed("%s was not updated because protocol %s is not supported.", 
 					$h, define($config{$h}{'protocol'}, '<undefined>')
 				  );
 		}
@@ -839,7 +898,7 @@ sub update_nics {
 ## unlink_pid()
 ######################################################################
 sub unlink_pid {
-    if (opt('pid') && opt('daemon')) {
+    if (opt('pid') && opt('daemon')) {	
 	unlink opt('pid');
     }
 }
@@ -850,7 +909,7 @@ sub unlink_pid {
 sub write_pid {
     my $file = opt('pid');
 
-    if ($file && opt('daemon')) {
+    if ($file && opt('daemon')) {	
         local *FD;
 	if (! open(FD, "> $file")) {
 	    warning("Cannot create file '%s'. ($!)", $file);
@@ -882,7 +941,7 @@ sub write_cache {
     my $cache = "";
     foreach my $h (sort keys %cache) {
     	my $opt = join(',', map { "$_=".define($cache{$h}{$_},'') } sort keys %{$cache{$h}});
-
+	    
         $cache .= sprintf "%s%s%s\n", $opt, ($opt ? ' ' : ''), $h;
     }
     $file = '' if defined($saved_cache) && $cache eq $saved_cache;
@@ -1004,7 +1063,7 @@ sub _read_config {
     }
     # Check for only owner has any access to config file
     my ($dev, $ino, $mode, @statrest) = stat(FD);
-    if ($mode & 077) {
+    if ($mode & 077) {                          
 	if (-f FD && (chmod 0600, $file)) {
 	    warning("file $file must be accessible only by its owner (fixed).");
 	} else {
@@ -1063,7 +1122,7 @@ sub _read_config {
 	($_, %locals) = parse_assignments($_);
 	s/\s*,\s*/,/g;
 	my @args = split;
-
+	
 	## verify that keywords are valid...and check the value
 	foreach my $k (keys %locals) {
 	    $locals{$k} = $passwords{$k} if defined $passwords{$k};
@@ -1086,19 +1145,19 @@ sub _read_config {
 	if ($#args < 0) {
 	    map { $globals{$_} = $locals{$_} } keys %locals;
 	}
-
+	
 	## process this host definition
 	if (@args) {
 	    my ($host, $login, $password) = @args;
-
+	    
 	    ## add in any globals..
 	    %locals = %{ merge(\%locals, \%globals) };
-
+	    
 	    ## override login and password if specified the old way.
 	    $locals{'login'}    = $login    if defined $login;
 	    $locals{'password'} = $password if defined $password;
-
-	    ## allow {host} to be a comma separated list of hosts
+	    
+	    ## allow {host} to be a comma separated list of hosts 
 	    foreach my $h (split_by_comma($host)) {
 		## save a copy of the current globals
 		$config{$h}         = { %locals };
@@ -1108,7 +1167,7 @@ sub _read_config {
 	%passwords = ();
     }
     close(FD);
-
+    
     warning("file ends while expecting a continuation line.")
       if $continuation;
 
@@ -1118,12 +1177,12 @@ sub _read_config {
     return $content;
 }
 ######################################################################
-## init_config -
+## init_config - 
 ######################################################################
 sub init_config {
     %opt = %saved_opt;
 
-    ##
+    ## 
     $opt{'quiet'}   = 0 if   opt('verbose');
 
     ## infer the IP strategy if possible
@@ -1144,7 +1203,7 @@ sub init_config {
         $opt{'daemon'} = minimum('daemon')
           if ($opt{'daemon'} < minimum('daemon'));
     }
-
+    
     ## define or modify host options specified on the command-line
     if (exists $opt{'options'} && defined $opt{'options'}) {
 	## collect cmdline configuration options.
@@ -1199,7 +1258,7 @@ sub init_config {
 	@hosts = map { $_ if $cache{$_}{'status'} ne 'good' } keys %cache;
     }
 
-    ## remove any other hosts
+    ## remove any other hosts 
     my %hosts;
     map { $hosts{$_} = undef } @hosts;
     map { delete $config{$_} unless exists $hosts{$_} } keys %config;
@@ -1235,6 +1294,7 @@ sub init_config {
 	$proto = opt('protocol')          if !defined($proto);
 
 	load_sha1_support() if ($proto eq "freedns");
+	load_json_support() if ($proto eq "cloudflare");
 
  	if (!exists($services{$proto})) {
 	    warning("skipping host: %s: unrecognized protocol '%s'", $h, $proto);
@@ -1281,24 +1341,24 @@ sub usage {
 }
 
 ######################################################################
-## process_args -
+## process_args - 
 ######################################################################
 sub process_args {
     my @spec  = ();
     my $usage = "";
     my %opts  = ();
-
+    
     foreach (@_) {
 	if (ref $_) {
 	    my ($key, $specifier, $arg_usage) = @$_;
 	    my $value = default($key);
-
+	    
 	    ## add a option specifier
 	    push @spec, $key . $specifier;
-
+	    
 	    ## define the default value which can be overwritten later
 	    $opt{$key} = undef;
-
+	    
 	    next unless $arg_usage;
 
 	    ## add a line to the usage;
@@ -1352,7 +1412,7 @@ sub test_possible_ip {
 	local $opt{'use'} = 'fw';
 	printf "use=fw, fw=%s address is %s\n", opt('fw'), define(get_ip(opt('fw')), 'NOT FOUND')
 	    if ! exists $builtinfw{opt('fw')};
-
+	
     }
     {
 	local $opt{'use'} = 'web';
@@ -1501,7 +1561,7 @@ sub pipecmd {
     return $ok;
 }
 sub logger {
-    if (opt('syslog') && opt('facility') &&  opt('priority')) {
+    if (opt('syslog') && opt('facility') &&  opt('priority')) { 
 	my $facility = opt('facility');
 	my $priority = opt('priority');
     	return pipecmd("logger -p$facility.$priority -t${program}\[$$\]", @_);
@@ -1529,11 +1589,11 @@ sub sendmail {
     $msgs      = '';
 }
 ######################################################################
-##  split_by_comma
+##  split_by_comma		
 ##  merge
-##  default
-##  minimum
-##  opt
+##  default    
+##  minimum    
+##  opt		
 ######################################################################
 sub split_by_comma {
     my $string = shift;
@@ -1654,7 +1714,7 @@ sub prettyinterval {
     my $m = $interval % 60; $interval /= 60;
     my $h = $interval % 24; $interval /= 24;
     my $d = $interval;
-
+    
     my $string = "";
     $string .= "$d day"    if $d;
     $string .= "s"         if $d > 1;
@@ -1744,7 +1804,7 @@ sub check_value {
 	return undef if $value eq "";
 
     } elsif ($type eq T_IF) {
-	return undef if $value !~ /^[a-z0-9:._-]+$/;
+	return undef if $value !~ /^[a-zA-Z0-9:._-]+$/;
 
     } elsif ($type eq T_PROG) {
 	return undef if $value eq "";
@@ -1789,6 +1849,7 @@ sub load_ssl_support {
 Error loading the Perl module IO::Socket::SSL needed for SSL connect.
 On Debian, the package libio-socket-ssl-perl must be installed.
 On Red Hat, the package perl-IO-Socket-SSL must be installed.
+On Alpine, the package perl-io-socket-ssl must be installed.
 EOM
     }
     import  IO::Socket::SSL;
@@ -1813,6 +1874,18 @@ EOM
     }
 }
 ######################################################################
+## load_json_support
+######################################################################
+sub load_json_support {
+	my $json_loaded = eval {require JSON::Any};
+	unless ($json_loaded) {
+		fatal(<<"EOM");
+Error loading the Perl module JSON::Any needed for cloudflare update.
+EOM
+	}
+	import JSON::Any;
+}
+######################################################################
 ## geturl
 ######################################################################
 sub geturl {
@@ -1834,10 +1907,10 @@ sub geturl {
     $server =~ s%/.*%%;
     $url    = "/" unless $url =~ m%/%;
     $url    =~ s%^[^/]*/%%;
-
+ 
     debug("server = $server");
     opt('fw') && debug("opt(fw = ",opt('fw'),")");
-    $globals{'fw'} && debug("glo fw = $globals{'fw'}");
+    $globals{'fw'} && debug("glo fw = $globals{'fw'}"); 
     #if ( $globals{'ssl'} and $server ne $globals{'fw'} ) {
     ## always omit SSL for connections to local router
     if ( $force_ssl || ($globals{'ssl'} and (caller(1))[3] ne 'main::get_ip') ) {
@@ -1848,7 +1921,7 @@ sub geturl {
         $use_ssl      = 0;
         $default_port = 80;
     }
-
+   
     ## determine peer and port to use.
     $peer   = $proxy || $server;
     $peer   =~ s%/.*%%;
@@ -1856,7 +1929,7 @@ sub geturl {
     $port   =~ s%^.*:%%;
     $port   = $default_port unless $port =~ /^\d+$/;
     $peer   =~ s%:.*$%%;
-
+  
     my $to =  sprintf "%s%s", $server, $proxy ? " via proxy $peer:$port" : "";
     verbose("CONNECT:", "%s", $to);
 
@@ -1865,7 +1938,7 @@ sub geturl {
     $request .= "/$url HTTP/1.0\n";
     $request .= "Host: $server\n";
 
-    my $auth = encode_base64("${login}:${password}");
+    my $auth = encode_base64("${login}:${password}", "");
     $request .= "Authorization: Basic $auth\n" if $login || $password;
     $request .= "User-Agent: ${program}/${version}\n";
     $request .= "Connection: close\n";
@@ -1980,7 +2053,7 @@ sub get_ip {
 	if (exists $builtinweb{$url}) {
 	    $skip = $builtinweb{$url}->{'skip'} unless $skip;
 	    $url  = $builtinweb{$url}->{'url'};
-	}
+	}	    
 	$arg = $url;
 
 	if ($url) {
@@ -2028,7 +2101,7 @@ sub get_ip {
 	if (exists $builtinfw{$use}) {
 	    $skip = $builtinfw{$use}->{'skip'} unless $skip;
 	    $url  = "http://${url}" . $builtinfw{$use}->{'url'} unless $url =~ /\//;
-	}
+	}	    
 	$arg = $url;
 
 	if ($url) {
@@ -2097,9 +2170,9 @@ Global definitions look like:
   name=value [,name=value]*
 
 For example:
-  daemon=5m
-  use=if, if=eth0
-  proxy=proxy.myisp.com
+  daemon=5m                   
+  use=if, if=eth0             
+  proxy=proxy.myisp.com       
   protocol=dyndns2
 
 specifies that ${program} should operate as a daemon, checking the
@@ -2115,7 +2188,7 @@ For example:
   login=my-hn-login, password=my-hn-password  myhost.hn.org
   login=my-login, password=my-password  myhost.dyndns.org,my2nd.dyndns.org
 
-specifies two host definitions.
+specifies two host definitions.  
 
 The first definition will use the hammernode1 protocol,
 my-hn-login and my-hn-password to update the ip-address of
@@ -2158,15 +2231,15 @@ sub nic_updateable {
 	$update = 1;
 
     } elsif ($cache{$host}{'wtime'} && $cache{$host}{'wtime'} > $now) {
-	warning("cannot update %s from %s to %s until after %s.",
-		$host,
+	warning("cannot update %s from %s to %s until after %s.", 
+		$host, 
 		($cache{$host}{'ip'} ? $cache{$host}{'ip'} : '<nothing>'), $ip,
 		prettytime($cache{$host}{'wtime'})
 	);
 
     } elsif ($cache{$host}{'mtime'} && interval_expired($host, 'mtime', 'max-interval')) {
-	warning("forcing update of %s from %s to %s; %s since last update on %s.",
-		$host,
+	warning("forcing update of %s from %s to %s; %s since last update on %s.", 
+		$host, 
 		($cache{$host}{'ip'} ? $cache{$host}{'ip'} : '<nothing>'), $ip,
 		prettyinterval($config{$host}{'max-interval'}),
 		prettytime($cache{$host}{'mtime'})
@@ -2175,29 +2248,29 @@ sub nic_updateable {
 
     } elsif ((!exists($cache{$host}{'ip'})) ||
 		    ("$cache{$host}{'ip'}" ne "$ip")) {
-	    if (($cache{$host}{'status'} eq 'good') &&
+	    if (($cache{$host}{'status'} eq 'good') && 
 			    !interval_expired($host, 'mtime', 'min-interval')) {
 
-	    warning("skipping update of %s from %s to %s.\nlast updated %s.\nWait at least %s between update attempts.",
-		 $host,
-		 ($cache{$host}{'ip'}    ? $cache{$host}{'ip'}                : '<nothing>'),
+	    warning("skipping update of %s from %s to %s.\nlast updated %s.\nWait at least %s between update attempts.", 
+		 $host, 
+		 ($cache{$host}{'ip'}    ? $cache{$host}{'ip'}                : '<nothing>'), 
 		 $ip,
 		 ($cache{$host}{'mtime'} ? prettytime($cache{$host}{'mtime'}) : '<never>'),
-		 prettyinterval($config{$host}{'min-interval'})
+		 prettyinterval($config{$host}{'min-interval'})		
 		 )
 		if opt('verbose') || !define($cache{$host}{'warned-min-interval'}, 0);
 
 	    $cache{$host}{'warned-min-interval'} = $now;
-
+	    
 	} elsif (($cache{$host}{'status'} ne 'good') && !interval_expired($host, 'atime', 'min-error-interval')) {
 
-	    warning("skipping update of %s from %s to %s.\nlast updated %s but last attempt on %s failed.\nWait at least %s between update attempts.",
-		 $host,
-		 ($cache{$host}{'ip'}    ? $cache{$host}{'ip'}                : '<nothing>'),
+	    warning("skipping update of %s from %s to %s.\nlast updated %s but last attempt on %s failed.\nWait at least %s between update attempts.", 
+		 $host, 
+		 ($cache{$host}{'ip'}    ? $cache{$host}{'ip'}                : '<nothing>'), 
 		 $ip,
 		 ($cache{$host}{'mtime'} ? prettytime($cache{$host}{'mtime'}) : '<never>'),
 		 ($cache{$host}{'atime'} ? prettytime($cache{$host}{'atime'}) : '<never>'),
-		 prettyinterval($config{$host}{'min-error-interval'})
+		 prettyinterval($config{$host}{'min-error-interval'})		
 		 )
 		if opt('verbose') || !define($cache{$host}{'warned-min-error-interval'}, 0);
 
@@ -2236,7 +2309,7 @@ sub nic_updateable {
 	delete $cache{$host}{'warned-min-interval'};
 	delete $cache{$host}{'warned-min-error-interval'};
     }
-
+	    
     return $update;
 }
 ######################################################################
@@ -2255,7 +2328,7 @@ sub header_ok {
 	} elsif ($result eq '401') {
 	    failed("updating %s: authorization failed (%s)", $host, $line);
 	}
-
+	
     } else {
 	failed("updating %s: unexpected line (%s)", $host, $line);
     }
@@ -2270,11 +2343,11 @@ o 'dyndns1'
 
 The 'dyndns1' protocol is a deprecated protocol used by the free dynamic
 DNS service offered by www.dyndns.org. The 'dyndns2' should be used to
-update the www.dyndns.org service.  However, other services are also
+update the www.dyndns.org service.  However, other services are also 
 using this protocol so support is still provided by ${program}.
 
 Configuration variables applicable to the 'dyndns1' protocol are:
-  protocol=dyndns1             ##
+  protocol=dyndns1             ## 
   server=fqdn.of.service       ## defaults to members.dyndns.org
   backupmx=no|yes              ## indicates that this host is the primary MX for the domain.
   mx=any.host.domain           ## a host MX'ing for this host definition.
@@ -2288,14 +2361,14 @@ Example ${program}.conf file entries:
   protocol=dyndns1,                                         \\
   login=my-dyndns.org-login,                                \\
   password=my-dyndns.org-password                           \\
-  myhost.dyndns.org
+  myhost.dyndns.org 
 
   ## multiple host update with wildcard'ing mx, and backupmx
   protocol=dyndns1,                                         \\
   login=my-dyndns.org-login,                                \\
   password=my-dyndns.org-password,                          \\
   mx=a.host.willing.to.mx.for.me,backupmx=yes,wildcard=yes  \\
-  myhost.dyndns.org,my2ndhost.dyndns.org
+  myhost.dyndns.org,my2ndhost.dyndns.org 
 EoEXAMPLE
 }
 ######################################################################
@@ -2320,7 +2393,7 @@ sub nic_dyndns1_update {
 	    $url .= "&mx=$config{$h}{'mx'}";
 	    $url .= "&backmx=" . ynu($config{$h}{'backupmx'}, 'YES', 'NO');
 	}
-
+	
 	my $reply = geturl(opt('proxy'), $url, $config{$h}{'login'}, $config{$h}{'password'});
 	if (!defined($reply) || !$reply) {
 	    failed("updating %s: Could not connect to %s.", $h, $config{$h}{'server'});
@@ -2335,14 +2408,14 @@ sub nic_dyndns1_update {
 	    $return_code = $1 if $line =~ m%^return\s+code\s*:\s*(.*)\s*$%i;
 	    $error_code  = $1 if $line =~ m%^error\s+code\s*:\s*(.*)\s*$%i;
 	}
-
+	
 	if ($return_code ne 'NOERROR' || $error_code ne 'NOERROR' || !$title) {
 	    $config{$h}{'status'} = 'failed';
 	    $title = "incomplete response from $config{$h}{server}" unless $title;
 	    warning("SENT:    %s", $url) unless opt('verbose');
 	    warning("REPLIED: %s", $reply);
 	    failed("updating %s: %s", $h, $title);
-
+	    
 	} else {
 	    $config{$h}{'ip'}     = $ip;
 	    $config{$h}{'mtime'}  = $now;
@@ -2387,7 +2460,7 @@ features of the older 'dyndns1' in addit
 supported in a future version of ${program}.]
 
 Configuration variables applicable to the 'dyndns2' protocol are:
-  protocol=dyndns2             ##
+  protocol=dyndns2             ## 
   server=fqdn.of.service       ## defaults to members.dyndns.org
   script=/path/to/script       ## defaults to /nic/update
   backupmx=no|yes              ## indicates that this host is the primary MX for the domain.
@@ -2404,14 +2477,14 @@ Example ${program}.conf file entries:
   protocol=dyndns2,                                         \\
   login=my-dyndns.org-login,                                \\
   password=my-dyndns.org-password                           \\
-  myhost.dyndns.org
+  myhost.dyndns.org 
 
   ## multiple host update with wildcard'ing mx, and backupmx
   protocol=dyndns2,                                         \\
   login=my-dyndns.org-login,                                \\
   password=my-dyndns.org-password,                          \\
   mx=a.host.willing.to.mx.for.me,backupmx=yes,wildcard=yes  \\
-  myhost.dyndns.org,my2ndhost.dyndns.org
+  myhost.dyndns.org,my2ndhost.dyndns.org 
 
   ## multiple host update to the custom DNS service
   protocol=dyndns2,                                         \\
@@ -2426,7 +2499,7 @@ EoEXAMPLE
 sub nic_dyndns2_update {
     debug("\nnic_dyndns2_update -------------------");
 
-    ## group hosts with identical attributes together
+    ## group hosts with identical attributes together 
     my %groups = group_hosts_by([ @_ ], [ qw(login password server static custom wildcard mx backupmx) ]);
 
     my %errors = (
@@ -2438,8 +2511,8 @@ sub nic_dyndns2_update {
        '!yours'   => 'The hostname specified exists, but not under the username currently being used',
        '!donator' => 'The offline setting was set, when the user is not a donator',
        '!active'  => 'The hostname specified is in a Custom DNS domain which has not yet been activated.',
-       'abuse',   => 'The hostname specified is blocked for abuse; you should receive an email notification ' .
-                     'which provides an unblock request link.  More info can be found on ' .
+       'abuse',   => 'The hostname specified is blocked for abuse; you should receive an email notification ' . 
+                     'which provides an unblock request link.  More info can be found on ' . 
                      'https://www.dyndns.com/support/abuse.html',
 
        'numhost'  => 'System error: Too many or too few hosts found. Contact support@dyndns.org',
@@ -2502,10 +2575,10 @@ sub nic_dyndns2_update {
 	foreach my $line (@reply) {
 	    if ($state eq 'header') {
 		$state = 'body';
-
+	    
 	    } elsif ($state eq 'body') {
 		$state = 'results' if $line eq '';
-
+	    
 	    } elsif ($state =~ /^results/) {
 		$state = 'results2';
 
@@ -2514,20 +2587,20 @@ sub nic_dyndns2_update {
 		my ($status, $returnedip) = split / /, lc $line;
 		$ip = $returnedip if (not $ip);
 		my $h = shift @hosts;
-
+	    
 		$config{$h}{'status'} = $status;
 		if ($status eq 'good') {
 		    $config{$h}{'ip'}     = $ip;
 		    $config{$h}{'mtime'}  = $now;
 		    success("updating %s: %s: IP address set to %s", $h, $status, $ip);
-
+		
 		} elsif (exists $errors{$status}) {
 		    if ($status eq 'nochg') {
 			warning("updating %s: %s: %s", $h, $status, $errors{$status});
 			$config{$h}{'ip'}     = $ip;
 		    	$config{$h}{'mtime'}  = $now;
 			$config{$h}{'status'} = 'good';
-
+		    
 		    } else {
 			failed("updating %s: %s: %s", $h, $status, $errors{$status});
 		    }
@@ -2535,7 +2608,7 @@ sub nic_dyndns2_update {
 		} elsif ($status =~ /w(\d+)(.)/) {
 		    my ($wait, $units) = ($1, lc $2);
 		    my ($sec,  $scale) = ($wait, 1);
-
+		
 		    ($scale, $units) = (1, 'seconds')   if $units eq 's';
 		    ($scale, $units) = (60, 'minutes')  if $units eq 'm';
 		    ($scale, $units) = (60*60, 'hours') if $units eq 'h';
@@ -2543,10 +2616,10 @@ sub nic_dyndns2_update {
 		    $sec = $wait * $scale;
 		    $config{$h}{'wtime'} = $now + $sec;
 		    warning("updating %s: %s: wait $wait $units before further updates", $h, $status, $ip);
-
+		
 		} else {
 		    failed("updating %s: %s: unexpected status (%s)", $h, $line);
-		}
+		} 	
 	    }
 	}
 	failed("updating %s: Could not connect to %s.", $hosts, $config{$h}{'server'})
@@ -2562,7 +2635,7 @@ sub nic_dyndns2_update {
 sub nic_noip_update {
     debug("\nnic_noip_update -------------------");
 
-    ## group hosts with identical attributes together
+    ## group hosts with identical attributes together 
     my %groups = group_hosts_by([ @_ ], [ qw(login password server static custom wildcard mx backupmx) ]);
 
     my %errors = (
@@ -2605,29 +2678,29 @@ sub nic_noip_update {
 	foreach my $line (@reply) {
 	    if ($state eq 'header') {
 		$state = 'body';
-
+	    
 	    } elsif ($state eq 'body') {
 		$state = 'results' if $line eq '';
-
+	    
 	    } elsif ($state =~ /^results/) {
 		$state = 'results2';
 
 		my ($status, $ip) = split / /, lc $line;
 		my $h = shift @hosts;
-
+	    
 		$config{$h}{'status'} = $status;
 		if ($status eq 'good') {
 		    $config{$h}{'ip'}     = $ip;
 		    $config{$h}{'mtime'}  = $now;
 		    success("updating %s: %s: IP address set to %s", $h, $status, $ip);
-
+		
 		} elsif (exists $errors{$status}) {
 		    if ($status eq 'nochg') {
 			warning("updating %s: %s: %s", $h, $status, $errors{$status});
 			$config{$h}{'ip'}     = $ip;
 		    	$config{$h}{'mtime'}  = $now;
 			$config{$h}{'status'} = 'good';
-
+		    
 		    } else {
 			failed("updating %s: %s: %s", $h, $status, $errors{$status});
 		    }
@@ -2635,7 +2708,7 @@ sub nic_noip_update {
 		} elsif ($status =~ /w(\d+)(.)/) {
 		    my ($wait, $units) = ($1, lc $2);
 		    my ($sec,  $scale) = ($wait, 1);
-
+		
 		    ($scale, $units) = (1, 'seconds')   if $units eq 's';
 		    ($scale, $units) = (60, 'minutes')  if $units eq 'm';
 		    ($scale, $units) = (60*60, 'hours') if $units eq 'h';
@@ -2643,10 +2716,10 @@ sub nic_noip_update {
 		    $sec = $wait * $scale;
 		    $config{$h}{'wtime'} = $now + $sec;
 		    warning("updating %s: %s: wait $wait $units before further updates", $h, $status, $ip);
-
+		
 		} else {
 		    failed("updating %s: %s: unexpected status (%s)", $h, $line);
-		}
+		} 	
 	    }
 	}
 	failed("updating %s: Could not connect to %s.", $hosts, $config{$h}{'server'})
@@ -2665,7 +2738,7 @@ over an http request.  Details of the pr
 http://www.no-ip.com/integrate/
 
 Configuration variables applicable to the 'noip' protocol are:
-  protocol=noip		           ##
+  protocol=noip		           ## 
   server=fqdn.of.service       ## defaults to dynupdate.no-ip.com
   login=service-login          ## login name and password  registered with the service
   password=service-password    ##
@@ -2676,7 +2749,7 @@ Example ${program}.conf file entries:
   protocol=noip,                                        \\
   login=userlogin\@domain.com,                                \\
   password=noip-password                           \\
-  myhost.no-ip.biz
+  myhost.no-ip.biz 
 
 
 EoEXAMPLE
@@ -2686,22 +2759,22 @@ EoEXAMPLE
 ## nic_concont_examples
 ######################################################################
 sub nic_concont_examples {
-    return <<EoEXAMPLE;
+    return <<EoEXAMPLE; 
 o 'concont'
-
+                          
 The 'concont' protocol is the protocol used by the content management
 system ConCont's dydns module. This is currently used by the free
 dynamic DNS service offered by Tyrmida at www.dydns.za.net
-
+    
 Configuration variables applicable to the 'concont' protocol are:
-  protocol=concont             ##
+  protocol=concont             ## 
   server=www.fqdn.of.service   ## for example www.dydns.za.net (for most add a www)
   login=service-login          ## login registered with the service
   password=service-password    ## password registered with the service
   mx=mail.server.fqdn          ## fqdn of the server handling domain\'s mail (leave out for none)
   wildcard=yes|no              ## set yes for wild (*.host.domain) support
   fully.qualified.host         ## the host registered with the service.
-
+                        
 Example ${program}.conf file entries:
   ## single host update
   protocol=concont,                                     \\
@@ -2709,8 +2782,8 @@ Example ${program}.conf file entries:
   password=my-dydns.za.net-password,                    \\
   mx=mailserver.fqdn,                                   \\
   wildcard=yes                                          \\
-  myhost.hn.org
-
+  myhost.hn.org           
+                        
 EoEXAMPLE
 }
 ######################################################################
@@ -2776,10 +2849,10 @@ sub nic_dslreports1_examples {
 o 'dslreports1'
 
 The 'dslreports1' protocol is used by a free DSL monitoring service
-offered by www.dslreports.com.
+offered by www.dslreports.com. 
 
 Configuration variables applicable to the 'dslreports1' protocol are:
-  protocol=dslreports1         ##
+  protocol=dslreports1         ## 
   server=fqdn.of.service       ## defaults to www.dslreports.com
   login=service-login          ## login name and password  registered with the service
   password=service-password    ##
@@ -2814,25 +2887,25 @@ sub nic_dslreports1_update {
 	$url  .= "?action=edit&started=1&hostname=YES&host_id=$h";
 	$url  .= "&myip=";
 	$url  .= $ip            if $ip;
-
+	
 	my $reply = geturl(opt('proxy'), $url, $config{$h}{'login'}, $config{$h}{'password'});
 	if (!defined($reply) || !$reply) {
 	    failed("updating %s: Could not connect to %s.", $h, $config{$h}{'server'});
 	    next;
 	}
-
+	
 	my @reply = split /\n/, $reply;
 	my $return_code = '';
 	foreach my $line (@reply) {
 	    $return_code = $1 if $line =~ m%^return\s+code\s*:\s*(.*)\s*$%i;
 	}
-
+	
 	if ($return_code !~ /NOERROR/) {
 	    $config{$h}{'status'} = 'failed';
 	    warning("SENT:    %s", $url) unless opt('verbose');
 	    warning("REPLIED: %s", $reply);
 	    failed("updating %s", $h);
-
+	    
 	} else {
 	    $config{$h}{'ip'}     = $ip;
 	    $config{$h}{'mtime'}  = $now;
@@ -2852,7 +2925,7 @@ The 'hammernode1' protocol is the protoc
 DNS service offered by Hammernode at www.hn.org
 
 Configuration variables applicable to the 'hammernode1' protocol are:
-  protocol=hammernode1         ##
+  protocol=hammernode1         ## 
   server=fqdn.of.service       ## defaults to members.dyndns.org
   login=service-login          ## login name and password  registered with the service
   password=service-password    ##
@@ -2863,7 +2936,7 @@ Example ${program}.conf file entries:
   protocol=hammernode1,                                 \\
   login=my-hn.org-login,                                \\
   password=my-hn.org-password                           \\
-  myhost.hn.org
+  myhost.hn.org 
 
   ## multiple host update
   protocol=hammernode1,                                 \\
@@ -2889,14 +2962,14 @@ sub nic_hammernode1_update {
 	$url  .= "?ver=1";
 	$url  .= "&ip=";
 	$url  .= $ip if $ip;
-
+	
 	my $reply = geturl(opt('proxy'), $url, $config{$h}{'login'}, $config{$h}{'password'});
 	if (!defined($reply) || !$reply) {
 	    failed("updating %s: Could not connect to %s.", $h, $config{$h}{'server'});
 	    last;
 	}
 	last if !header_ok($h, $reply);
-
+	
 	my @reply = split /\n/, $reply;
 	if (grep /<!--\s+DDNS_Response_Code=101\s+-->/i, @reply) {
 	    $config{$h}{'ip'}     = $ip;
@@ -2922,7 +2995,7 @@ The 'zoneedit1' protocol is used by a DN
 www.zoneedit.com.
 
 Configuration variables applicable to the 'zoneedit1' protocol are:
-  protocol=zoneedit1           ##
+  protocol=zoneedit1           ## 
   server=fqdn.of.service       ## defaults to www.zoneedit.com
   zone=zone-where-domains-are  ## only needed if 1 or more subdomains are deeper
                                ## than 1 level in relation to  the zone where it
@@ -2960,7 +3033,7 @@ sub nic_zoneedit1_updateable {
 sub nic_zoneedit1_update {
     debug("\nnic_zoneedit1_update -------------------");
 
-    ## group hosts with identical attributes together
+    ## group hosts with identical attributes together 
     my %groups = group_hosts_by([ @_ ], [ qw(login password server zone) ]);
 
     ## update each set of hosts that had similar configurations
@@ -3009,7 +3082,7 @@ sub nic_zoneedit1_update {
 		    } else {
 	    		$config{$h}{'status'} = 'failed';
 			failed("updating %s: %s: %s", $h, $status_code, $status_text);
-		    }
+		    } 	
 		    shift @hosts;
 		    $h     = $hosts[0];
 		    $hosts = join(',', @hosts);
@@ -3021,7 +3094,7 @@ sub nic_zoneedit1_update {
 	failed("updating %s: no response from %s", $hosts, $config{$h}{'server'})
 	      if @hosts;
     }
-}
+}	
 ######################################################################
 ## nic_easydns_updateable
 ######################################################################
@@ -3052,13 +3125,13 @@ sub nic_easydns_examples {
     return <<EoEXAMPLE;
 o 'easydns'
 
-The 'easydns' protocol is used by the for fee DNS service offered
+The 'easydns' protocol is used by the for fee DNS service offered 
 by www.easydns.com.
 
 Configuration variables applicable to the 'easydns' protocol are:
-  protocol=easydns             ##
+  protocol=easydns             ## 
   server=fqdn.of.service       ## defaults to members.easydns.com
-  backupmx=no|yes              ## indicates that EasyDNS should be the secondary MX
+  backupmx=no|yes              ## indicates that EasyDNS should be the secondary MX 
                                ## for this domain or host.
   mx=any.host.domain           ## a host MX'ing for this host or domain.
   wildcard=no|yes              ## add a DNS wildcard CNAME record that points to {host}
@@ -3071,7 +3144,7 @@ Example ${program}.conf file entries:
   protocol=easydns,                                         \\
   login=my-easydns.com-login,                               \\
   password=my-easydns.com-password                          \\
-  myhost.easydns.com
+  myhost.easydns.com 
 
   ## multiple host update with wildcard'ing mx, and backupmx
   protocol=easydns,                                         \\
@@ -3095,7 +3168,7 @@ EoEXAMPLE
 sub nic_easydns_update {
     debug("\nnic_easydns_update -------------------");
 
-    ## group hosts with identical attributes together
+    ## group hosts with identical attributes together 
     ## my %groups = group_hosts_by([ @_ ], [ qw(login password server wildcard mx backupmx) ]);
 
     ## each host is in a group by itself
@@ -3139,52 +3212,52 @@ sub nic_easydns_update {
 	    last;
 	}
 	last if !header_ok($hosts, $reply);
-
+	
 	my @reply = split /\n/, $reply;
 	my $state = 'header';
 	foreach my $line (@reply) {
 	    if ($state eq 'header') {
 		$state = 'body';
-
+	    
 	    } elsif ($state eq 'body') {
 		$state = 'results' if $line eq '';
-
+	    
 	    } elsif ($state =~ /^results/) {
 		$state = 'results2';
 
 		my ($status) = $line =~ /^(\S*)\b.*/;
 		my $h = shift @hosts;
-
+	    
 		$config{$h}{'status'} = $status;
 		if ($status eq 'NOERROR') {
 		    $config{$h}{'ip'}     = $ip;
 		    $config{$h}{'mtime'}  = $now;
 		    success("updating %s: %s: IP address set to %s", $h, $status, $ip);
-
+		
 		} elsif ($status =~ /TOOSOON/) {
 		    ## make sure we wait at least a little
 		    my ($wait, $units) = (5, 'm');
 		    my ($sec,  $scale) = ($wait, 1);
-
+		
 		    ($scale, $units) = (1, 'seconds')   if $units eq 's';
 		    ($scale, $units) = (60, 'minutes')  if $units eq 'm';
 		    ($scale, $units) = (60*60, 'hours') if $units eq 'h';
 		    $config{$h}{'wtime'} = $now + $sec;
 		    warning("updating %s: %s: wait $wait $units before further updates", $h, $status, $ip);
-
+		
 		} elsif (exists $errors{$status}) {
 		    failed("updating %s: %s: %s", $h, $line, $errors{$status});
 
 		} else {
 		    failed("updating %s: %s: unexpected status (%s)", $h, $line);
-		}
+		} 	
 		last;
 	    }
 	}
 	failed("updating %s: Could not connect to %s.", $hosts, $config{$h}{'server'})
 	    if $state ne 'results2';
     }
-}
+}	
 ######################################################################
 
 ######################################################################
@@ -3214,9 +3287,9 @@ o 'dnspark'
 The 'dnspark' protocol is used by DNS service offered by www.dnspark.com.
 
 Configuration variables applicable to the 'dnspark' protocol are:
-  protocol=dnspark             ##
+  protocol=dnspark             ## 
   server=fqdn.of.service       ## defaults to www.dnspark.com
-  backupmx=no|yes              ## indicates that DNSPark should be the secondary MX
+  backupmx=no|yes              ## indicates that DNSPark should be the secondary MX 
                                ## for this domain or host.
   mx=any.host.domain           ## a host MX'ing for this host or domain.
   mxpri=priority               ## MX priority.
@@ -3229,7 +3302,7 @@ Example ${program}.conf file entries:
   protocol=dnspark,                                         \\
   login=my-dnspark.com-login,                               \\
   password=my-dnspark.com-password                          \\
-  myhost.dnspark.com
+  myhost.dnspark.com 
 
   ## multiple host update with wildcard'ing mx, and backupmx
   protocol=dnspark,                                         \\
@@ -3252,7 +3325,7 @@ EoEXAMPLE
 sub nic_dnspark_update {
     debug("\nnic_dnspark_update -------------------");
 
-    ## group hosts with identical attributes together
+    ## group hosts with identical attributes together 
     ## my %groups = group_hosts_by([ @_ ], [ qw(login password server wildcard mx backupmx) ]);
 
     ## each host is in a group by itself
@@ -3298,52 +3371,52 @@ sub nic_dnspark_update {
 	    last;
 	}
 	last if !header_ok($hosts, $reply);
-
+	
 	my @reply = split /\n/, $reply;
 	my $state = 'header';
 	foreach my $line (@reply) {
 	    if ($state eq 'header') {
 		$state = 'body';
-
+	    
 	    } elsif ($state eq 'body') {
 		$state = 'results' if $line eq '';
-
+	    
 	    } elsif ($state =~ /^results/) {
 		$state = 'results2';
 
 		my ($status) = $line =~ /^(\S*)\b.*/;
 		my $h = pop @hosts;
-
+	    
 		$config{$h}{'status'} = $status;
 		if ($status eq 'ok') {
 		    $config{$h}{'ip'}     = $ip;
 		    $config{$h}{'mtime'}  = $now;
 		    success("updating %s: %s: IP address set to %s", $h, $status, $ip);
-
+		
 		} elsif ($status =~ /TOOSOON/) {
 		    ## make sure we wait at least a little
 		    my ($wait, $units) = (5, 'm');
 		    my ($sec,  $scale) = ($wait, 1);
-
+		
 		    ($scale, $units) = (1, 'seconds')   if $units eq 's';
 		    ($scale, $units) = (60, 'minutes')  if $units eq 'm';
 		    ($scale, $units) = (60*60, 'hours') if $units eq 'h';
 		    $config{$h}{'wtime'} = $now + $sec;
 		    warning("updating %s: %s: wait $wait $units before further updates", $h, $status, $ip);
-
+		
 		} elsif (exists $errors{$status}) {
 		    failed("updating %s: %s: %s", $h, $line, $errors{$status});
 
 		} else {
 		    failed("updating %s: %s: unexpected status (%s)", $h, $line);
-		}
+		} 	
 		last;
 	    }
 	}
 	failed("updating %s: Could not connect to %s.", $hosts, $config{$h}{'server'})
 	    if $state ne 'results2';
     }
-}
+}	
 
 ######################################################################
 
@@ -3358,7 +3431,7 @@ o 'namecheap'
 The 'namecheap' protocol is used by DNS service offered by www.namecheap.com.
 
 Configuration variables applicable to the 'namecheap' protocol are:
-  protocol=namecheap           ##
+  protocol=namecheap           ## 
   server=fqdn.of.service       ## defaults to dynamicdns.park-your-domain.com
   login=service-login          ## login name and password  registered with the service
   password=service-password    ##
@@ -3369,7 +3442,7 @@ Example ${program}.conf file entries:
   protocol=namecheap,                                         \\
   login=my-namecheap.com-login,                               \\
   password=my-namecheap.com-password                          \\
-  myhost.namecheap.com
+  myhost.namecheap.com 
 
 EoEXAMPLE
 }
@@ -3397,8 +3470,11 @@ sub nic_namecheap_update {
 
         my $url;
         $url   = "http://$config{$h}{'server'}/update";
-        $url  .= "?host=$h";
-        $url  .= "&domain=$config{$h}{'login'}";
+	my $domain = $config{$h}{'login'};
+	my $host = $h;
+	$host  =~ s/(.*)\.$domain(.*)/$1$2/;
+	$url  .= "?host=$host";
+	$url  .= "&domain=$domain";
         $url  .= "&password=$config{$h}{'password'}";
         $url  .= "&ip=";
         $url  .= $ip if $ip;
@@ -3441,7 +3517,7 @@ o 'sitelutions'
 The 'sitelutions' protocol is used by DNS services offered by www.sitelutions.com.
 
 Configuration variables applicable to the 'sitelutions' protocol are:
-  protocol=sitelutions         ##
+  protocol=sitelutions         ## 
   server=fqdn.of.service       ## defaults to sitelutions.com
   login=service-login          ## login name and password  registered with the service
   password=service-password    ##
@@ -3508,11 +3584,11 @@ sub nic_sitelutions_update {
     }
 }
 
-######################################################################
+###################################################################### 
 
-######################################################################
-## nic_freedns_examples
-######################################################################
+###################################################################### 
+## nic_freedns_examples 
+###################################################################### 
 sub nic_freedns_examples {
 return <<EoEXAMPLE;
 
@@ -3535,7 +3611,7 @@ Example ${program}.conf file entries:
   myhost.afraid.com
 
 EoEXAMPLE
-}
+} 
 ######################################################################
 ## nic_freedns_update
 ##
@@ -3579,27 +3655,27 @@ sub nic_freedns_update {
 	info("setting IP address to %s for %s", $ip, $h);
 	verbose("UPDATE:","updating %s", $h);
 
-	if($ip eq $freedns_hosts{$h}->[1]) {
-	    $config{$h}{'ip'}     = $ip;
-	    $config{$h}{'mtime'}  = $now;
-	    $config{$h}{'status'} = 'good';
-	    success("update not necessary %s: good: IP address already set to %s", $h, $ip);
+	if($ip eq $freedns_hosts{$h}->[1]) { 
+	    $config{$h}{'ip'}     = $ip; 
+	    $config{$h}{'mtime'}  = $now; 
+	    $config{$h}{'status'} = 'good'; 
+	    success("update not necessary %s: good: IP address already set to %s", $h, $ip); 
 	} else {
 	    my $reply = geturl(opt('proxy'), $freedns_hosts{$h}->[2]);
 	    if (!defined($reply) || !$reply) {
 	        failed("updating %s: Could not connect to %s.", $h, $freedns_hosts{$h}->[2]);
 		last;
 	    }
-	    if(!header_ok($h, $reply)) {
-		$config{$h}{'status'} = 'failed';
-		last;
+	    if(!header_ok($h, $reply)) { 
+		$config{$h}{'status'} = 'failed'; 
+		last; 
 	    }
 
-	    if($reply =~ /Updated.*$h.*to.*$ip/) {
-		$config{$h}{'ip'}     = $ip;
-		$config{$h}{'mtime'}  = $now;
-		$config{$h}{'status'} = 'good';
-		success("updating %s: good: IP address set to %s", $h, $ip);
+	    if($reply =~ /Updated.*$h.*to.*$ip/) { 
+		$config{$h}{'ip'}     = $ip; 
+		$config{$h}{'mtime'}  = $now; 
+		$config{$h}{'status'} = 'good'; 
+		success("updating %s: good: IP address set to %s", $h, $ip); 
 	    } else {
 	        $config{$h}{'status'} = 'failed';
 		warning("SENT: %s", $freedns_hosts{$h}->[2]) unless opt('verbose');
@@ -3610,9 +3686,9 @@ sub nic_freedns_update {
     }
 }
 
-######################################################################
-## nic_changeip_examples
-######################################################################
+###################################################################### 
+## nic_changeip_examples 
+###################################################################### 
 sub nic_changeip_examples {
 return <<EoEXAMPLE;
 
@@ -3635,7 +3711,7 @@ Example ${program}.conf file entries:
   myhost.changeip.org
 
 EoEXAMPLE
-}
+} 
 
 ######################################################################
 ## nic_changeip_update
@@ -3688,27 +3764,27 @@ sub nic_changeip_update {
 ## nic_dtdns_examples
 ######################################################################
 sub nic_dtdns_examples {
-    return <<EoEXAMPLE;
+    return <<EoEXAMPLE; 
 o 'dtdns'
-
+                          
 The 'dtdns' protocol is the protocol used by the dynamic hostname services
 of the 'DtDNS' dns services. This is currently used by the free
 dynamic DNS service offered by www.dtdns.com.
-
+    
 Configuration variables applicable to the 'dtdns' protocol are:
-  protocol=dtdns               ##
+  protocol=dtdns               ## 
   server=www.fqdn.of.service   ## defaults to www.dtdns.com
   password=service-password    ## password registered with the service
   client=name_of_updater       ## defaults to $program (10 chars max, no spaces)
   fully.qualified.host         ## the host registered with the service.
-
+                        
 Example ${program}.conf file entries:
   ## single host update
   protocol=dtdns,                                       \\
   password=my-dydns.za.net-password,                    \\
   client=ddclient                                       \\
   myhost.dtdns.net
-
+                        
 EoEXAMPLE
 }
 
@@ -3764,6 +3840,389 @@ sub nic_dtdns_update {
          }
     }
 }
+######################################################################
+
+######################################################################
+## nic_googledomains_examples
+##
+## written by Nelson Araujo
+##
+######################################################################
+sub nic_googledomains_examples {
+    return <<EoEXAMPLE;
+o 'googledomains'
+
+The 'googledomains' protocol is used by DNS service offered by www.google.com/domains.
+
+Configuration variables applicable to the 'googledomains' protocol are:
+  protocol=googledomains       ##
+  login=service-login          ## the user name provided by the admin interface
+  password=service-password    ## the password provided by the admin interface
+  fully.qualified.host         ## the host registered with the service.
+
+Example ${program}.conf file entries:
+  ## single host update
+  protocol=googledomains,                                      \\
+  login=my-generated-user-name,                                \\
+  password=my-genereated-password                              \\
+  myhost.com
+
+  ## multiple host update to the custom DNS service
+  protocol=googledomains,                                      \\
+  login=my-generated-user-name,                                \\
+  password=my-genereated-password                              \\
+  my-toplevel-domain.com,my-other-domain.com
+EoEXAMPLE
+}
+######################################################################
+## nic_googledomains_update
+######################################################################
+sub nic_googledomains_update {
+  debug("\nnic_googledomains_update -------------------");
+
+  ## group hosts with identical attributes together
+  my %groups = group_hosts_by([ @_ ], [ qw(server login password) ]);
+
+  ## update each set of hosts that had similar configurations
+  foreach my $sig (keys %groups) {
+    my @hosts = @{$groups{$sig}};
+    my $key   = $hosts[0];
+    my $ip    = $config{$key}{'wantip'};
+
+    # FQDNs
+    for my $host (@hosts) {
+      delete $config{$host}{'wantip'};
+
+      info("setting IP address to %s for %s", $ip, $host);
+      verbose("UPDATE:","updating %s", $host);
+
+      # Update the DNS record
+      my $url = "https://$config{$host}{'server'}/nic/update";
+      $url   .= "?hostname=$host";
+      $url   .= "&myip=";
+      $url   .= $ip if $ip;
+
+      my $reply = geturl(opt('proxy'), $url, $config{$host}{'login'}, $config{$host}{'password'});
+      unless ($reply) {
+        failed("updating %s: Could not connect to %s.", $host, $config{$host}{'server'});
+        last;
+      }
+      last if !header_ok($host, $reply);
+
+      # Cache
+      $config{$host}{'ip'}     = $ip;
+      $config{$host}{'mtime'}  = $now;
+      $config{$host}{'status'} = 'good';
+    }
+  }
+}
+
+######################################################################
+## nic_nsupdate_examples
+######################################################################
+sub nic_nsupdate_examples {
+ return <<EoEXAMPLE;
+o 'nsupdate'
+
+The 'nsupdate' protocol is used to submit Dynamic DNS Update requests as
+defined in RFC2136 to a name server using the 'nsupdate' command line
+utility part of ISC BIND.  Dynamic DNS updates allow resource records to
+be added or removed from a zone configured for dynamic updates through
+DNS requests protected using TSIG.  BIND ships with 'ddns-confgen', a
+utility to generate sample configurations and instructions for both the
+server and the client.  See nsupdate(1) and ddns-confgen(8) for details.
+
+Configuration variables applicable to the 'nsupdate' protocol are:
+  protocol=nsupdate
+  server=ns1.example.com       ## name or IP address of the DNS server to send
+                               ## the update requests to; usually master for
+                               ## zone, but slaves should forward the request
+  password=tsig.key            ## path and name of the symmetric HMAC key file
+                               ## to use for TSIG signing of the request
+                               ## (as generated by 'ddns-confgen -q' and
+                               ## configured on server in 'grant' statement)
+  zone=dyn.example.com         ## forward zone that is to be updated
+  ttl=600                      ## time to live of the record;
+                               ## defaults to 600 seconds
+  login=/usr/bin/nsupdate      ## path and name of nsupdate binary;
+                               ## defaults to '/usr/bin/nsupdate'
+  <hostname>                   ## fully qualified hostname to update
+
+Example ${program}.conf file entries:
+  ## single host update
+  protocol=nsupdate \\
+  server=ns1.example.com \\
+  password=/etc/${program}/dyn.example.com.key \\
+  zone=dyn.example.com \\
+  ttl=3600 \\
+  myhost.dyn.example.com
+
+EoEXAMPLE
+}
+
+######################################################################
+## nic_nsupdate_update
+## by Daniel Roethlisberger <daniel@roe.ch>
+######################################################################
+sub nic_nsupdate_update {
+	debug("\nnic_nsupdate_update -------------------");
+
+	## group hosts with identical attributes together
+	my %groups = group_hosts_by([ @_ ], [ qw(login password server zone) ]);
+
+	## update each set of hosts that had similar configurations
+	foreach my $sig (keys %groups) {
+		my @hosts = @{$groups{$sig}};
+		my $hosts = join(',', @hosts);
+		my $h = $hosts[0];
+		my $binary = $config{$h}{'login'};
+		my $keyfile = $config{$h}{'password'};
+		my $server = $config{$h}{'server'};
+		my $zone = $config{$h}{'zone'};
+		my $ip = $config{$h}{'wantip'};
+		delete $config{$_}{'wantip'} foreach @hosts;
+
+		info("setting IP address to %s for %s", $ip, $hosts);
+		verbose("UPDATE:","updating %s", $hosts);
+
+		## send separate requests for each zone with all hosts in that zone
+		my $instructions = <<EoINSTR1;
+server $server
+zone $zone.
+EoINSTR1
+		foreach (@hosts) {
+			$instructions .= <<EoINSTR2;
+update delete $_. A
+update add $_. $config{$_}{'ttl'} A $ip
+EoINSTR2
+		}
+		$instructions .= <<EoINSTR3;
+send
+EoINSTR3
+		my $command = "$binary -k $keyfile";
+		$command .= " -d" if (opt('debug'));
+		verbose("UPDATE:", "nsupdate command is: %s", $command);
+		verbose("UPDATE:", "nsupdate instructions are:\n%s", $instructions);
+
+		my $status = pipecmd($command, $instructions);
+		if ($status eq 1) {
+			foreach (@hosts) {
+				$config{$_}{'ip'} = $ip;
+				$config{$_}{'mtime'} = $now;
+				$config{$_}{'status'} = 'good';
+				success("updating %s: %s: IP address set to %s", $_, $status, $ip);
+			}
+		} else {
+			foreach (@hosts) {
+				failed("updating %s", $_);
+			}
+		}
+	}
+}
+
+######################################################################
+
+######################################################################
+## nic_cloudflare_examples
+##
+## written by Ian Pye
+##
+######################################################################
+sub nic_cloudflare_examples {
+    return <<EoEXAMPLE;
+o 'cloudflare'
+
+The 'cloudflare' protocol is used by DNS service offered by www.cloudflare.com.
+
+Configuration variables applicable to the 'cloudflare' protocol are:
+  protocol=cloudflare          ## 
+  server=fqdn.of.service       ## defaults to www.cloudflare.com
+  login=service-login          ## login name and password  registered with the service
+  password=service-password    ##
+  fully.qualified.host         ## the host registered with the service.
+
+Example ${program}.conf file entries:
+  ## single host update
+  protocol=cloudflare,                                         \\
+  zone=dns.zone,                                               \\
+  login=my-cloudflare.com-login,                               \\
+  password=my-cloudflare.com-secure-token                      \\
+  myhost.com 
+
+  ## multiple host update to the custom DNS service
+  protocol=cloudflare,                                         \\
+  zone=dns.zone,                                               \\
+  login=my-cloudflare.com-login,                               \\
+  password=my-cloudflare.com-secure-token                      \\
+  my-toplevel-domain.com,my-other-domain.com
+EoEXAMPLE
+}
+######################################################################
+## nic_cloudflare_update
+######################################################################
+sub nic_cloudflare_update {
+	debug("\nnic_cloudflare_update -------------------");
+
+	## group hosts with identical attributes together 
+	my %groups = group_hosts_by([ @_ ], [ qw(ssh login password server wildcard mx backupmx zone) ]);
+
+	## update each set of hosts that had similar configurations
+	foreach my $sig (keys %groups) {
+		my @hosts = @{$groups{$sig}};
+		my $hosts = join(',', @hosts);
+		my $key   = $hosts[0];
+		my $ip    = $config{$key}{'wantip'};
+
+		# FQDNs
+		for my $domain (@hosts) {
+			(my $hostname = $domain) =~ s/\.$config{$key}{zone}$//;
+			delete $config{$domain}{'wantip'};
+
+			info("setting IP address to %s for %s", $ip, $domain);
+			verbose("UPDATE:","updating %s", $domain);
+
+			# Get domain ID
+			my $url = "https://$config{$key}{'server'}/api_json.html?a=rec_load_all";
+			$url   .= "&z=".$config{$key}{'zone'};
+			$url   .= "&email=".$config{$key}{'login'};	
+			$url   .= "&tkn=".$config{$key}{'password'};
+
+			my $reply = geturl(opt('proxy'), $url);
+			unless ($reply) {
+				failed("updating %s: Could not connect to %s.", $domain, $config{$key}{'server'});
+				last;
+			}
+			last if !header_ok($domain, $reply);
+
+			# Strip header
+			$reply =~ s/^.*?\n\n//s;
+			my $response = JSON::Any->jsonToObj($reply);
+			if ($response->{result} eq 'error') {
+				failed ("%s", $response->{msg});
+				next; 
+			}
+
+			# Pull the ID out of the json, messy
+			my ($id) = map { $_->{name} eq $domain ? $_->{rec_id} : () } @{ $response->{response}->{recs}->{objs} };
+			unless($id) {
+				failed("updating %s: No domain ID found.", $domain);
+				next;
+			}
+
+			# Set domain
+			$url   = "https://$config{$key}{'server'}/api_json.html?a=rec_edit&type=A&ttl=1";
+			$url     .= "&name=$hostname";
+			$url     .= "&z=".$config{$key}{'zone'};
+			$url     .= "&id=".$id;	
+			$url     .= "&email=".$config{$key}{'login'};	
+			$url     .= "&tkn=".$config{$key}{'password'};    
+			$url     .= "&content=";
+			$url     .= "$ip"       if $ip;
+
+			$reply = geturl(opt('proxy'), $url);
+			unless ($reply) {
+				failed("updating %s: Could not connect to %s.", $domain, $config{$domain}{'server'});
+				last;
+			}
+			last if !header_ok($domain, $reply);
+
+			# Strip header
+			$reply =~ s/^.*?\n\n//s;
+			$response = JSON::Any->jsonToObj($reply);
+			if ($response->{result} eq 'error') {
+				failed ("%s", $response->{msg});	
+			} else {
+				success ("%s -- Updated Successfully to %s", $domain, $ip);
+
+			}
+
+			# Cache
+			$config{$key}{'ip'}     = $ip;
+			$config{$key}{'mtime'}  = $now;
+			$config{$key}{'status'} = 'good';
+		}
+	}
+}
+
+######################################################################
+## nic_duckdns_examples
+######################################################################
+sub nic_duckdns_examples {
+    return <<EoEXAMPLE;
+o 'duckdns'
+
+The 'duckdns' protocol is used by the free
+dynamic DNS service offered by www.duckdns.org.
+Check http://www.duckdns.org/install.jsp?tab=linux-cron for API
+
+Configuration variables applicable to the 'duckdns' protocol are:
+  protocol=duckdns               ##
+  server=www.fqdn.of.service   ## defaults to www.duckdns.org
+  password=service-password    ## password (token) registered with the service
+  non-fully.qualified.host         ## the host registered with the service.
+
+Example ${program}.conf file entries:
+  ## single host update
+  protocol=duckdns,                                       \\
+  password=z0mgs3cjur3p4ss                    \\
+  myhost
+
+EoEXAMPLE
+}
+
+######################################################################
+## nic_duckdns_update
+## by George Kranis (copypasta from nic_dtdns_update)
+## http://www.duckdns.org/update?domains=mydomain1,mydomain2&token=xxxx-xxx-xx-x&ip=x.x.x.x
+## response contains OK or KO
+######################################################################
+sub nic_duckdns_update {
+    debug("\nnic_duckdns_update -------------------");
+
+    ## update each configured host
+    ## should improve to update in one pass
+    foreach my $h (@_) {
+        my $ip = delete $config{$h}{'wantip'};
+        info("setting IP address to %s for %s", $ip, $h);
+        verbose("UPDATE:","updating %s", $h);
+
+        # Set the URL that we're going to to update
+        my $url;
+        $url  = "http://$config{$h}{'server'}/update";
+        $url .= "?domains=";
+        $url .= $h;
+        $url .= "&token=";
+        $url .= $config{$h}{'password'};
+        $url .= "&ip=";
+        $url .= $ip;
+        
+
+        # Try to get URL
+        my $reply = geturl(opt('proxy'), $url);
+
+        # No response, declare as failed
+        if (!defined($reply) || !$reply) {
+            failed("updating %s: Could not connect to %s.", $h, $config{$h}{'server'});
+            last;
+        }
+        last if !header_ok($h, $reply);
+
+        my @reply = split /\n/, $reply;
+        my $returned = pop(@reply);
+        if ($returned =~ /OK/)
+        {
+                $config{$h}{'ip'}     = $ip;
+                $config{$h}{'mtime'}  = $now;
+                $config{$h}{'status'} = 'good';
+                success("updating %s: good: IP address set to %s", $h, $ip);
+         }
+         else
+         {
+                $config{$h}{'status'} = 'failed';
+                failed("updating %s: Server said: '$returned'", $h);
+         }
+    }
+}
 
 ######################################################################
 # vim: ai ts=4 sw=4 tw=78 :
